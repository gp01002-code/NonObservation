<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自我觀測儀 | 完整版</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        :root {
            --glow-color: #d4a574;     /* 復古琥珀黃 */
            --glow-bright: #e8c891;    /* 亮琥珀黃 */
            --crt-bg: #050805;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: var(--glow-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 手機直向提示 */
        @media (max-width: 768px) and (orientation: portrait) {
            body::before {
                content: "請將手機橫向旋轉 ↻\A以獲得最佳體驗";
                white-space: pre;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.95);
                color: var(--glow-bright);
                padding: 30px 20px;
                border: 3px solid var(--glow-color);
                border-radius: 15px;
                z-index: 9999;
                font-size: 16px;
                text-align: center;
                max-width: 80%;
                box-shadow: 0 0 30px var(--glow-color);
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.05); }
            }
            
            .machine-wrapper {
                opacity: 0.2;
                pointer-events: none;
                filter: blur(3px);
            }
        }
        
        /* 手機橫向優化 */
        @media (max-width: 768px) and (orientation: landscape) {
            .machine-wrapper {
                width: 98vw;
                max-width: none;
            }
            
            .knob-value {
                font-size: clamp(8px, 2vw, 10px);
            }
        }
        
        /* 平板優化 */
        @media (min-width: 769px) and (max-width: 1024px) {
            .machine-wrapper {
                width: 95vw;
            }
        }

        .machine-wrapper {
            position: relative;
            width: 95vw;
            max-width: 1000px;
            aspect-ratio: 1000 / 667; 
            background-color: #1a1a1a;
            box-shadow: 0 0 100px rgba(212, 165, 116, 0.1);
        }
        
        /* 後方背景層 - Image2.png（電子結構） */
        .machine-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('Image2.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 0;
            animation: floatBackground 8s ease-in-out infinite;
        }
        
        /* 前方背景層 - Image.png（原本的機器面板，透明度 40%） */
        .machine-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('Image.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.4;
            z-index: 1;
            animation: floatForeground 6s ease-in-out infinite;
        }
        
        /* 浮動動畫 - 後方背景（慢速、大範圍） */
        @keyframes floatBackground {
            0%, 100% {
                transform: translate(0, 0) scale(1);
            }
            25% {
                transform: translate(8px, -6px) scale(1.01);
            }
            50% {
                transform: translate(-5px, 8px) scale(0.99);
            }
            75% {
                transform: translate(-8px, -5px) scale(1.01);
            }
        }
        
        /* 浮動動畫 - 前方背景（快速、小範圍） */
        @keyframes floatForeground {
            0%, 100% {
                transform: translate(0, 0);
            }
            33% {
                transform: translate(-3px, 4px);
            }
            66% {
                transform: translate(4px, -3px);
            }
        }

        /* 螢幕區域 - 完美對齊 */
        .screen-container {
            position: absolute;
            top: 8.5%;
            left: 25.5%;    /* 往右移（內縮左邊） */
            width: 49%;     /* 縮小寬度（內縮左右） */
            height: 54%;
            background: var(--crt-bg);
            border-radius: 4px;
            overflow: hidden;
            z-index: 2;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.05), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.05));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* 旋鈕 + 數值顯示 */
        .knob-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .knob-left { 
            top: 8%; left: 6.5%; 
            width: 15%; height: 25%;
        }
        
        .knob-right { 
            top: 8%; right: 6.5%; 
            width: 15%; height: 25%;
        }

        .knob-area {
            width: 100%;
            height: 85%;
            cursor: ns-resize; 
            background: transparent;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .knob-area:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .knob-area.active {
            background: rgba(212, 165, 116, 0.2);
            box-shadow: 0 0 15px rgba(212, 165, 116, 0.5);
        }

        .knob-value {
            margin-top: 5%;
            font-size: clamp(9px, 1vw, 11px);
            color: var(--glow-bright);
            text-shadow: 0 0 8px var(--glow-color);
            text-align: center;
            font-weight: bold;
        }

        /* 模式選擇器 */
        .mode-selector {
            position: absolute;
            bottom: 16%; left: 28%;
            width: 44%; height: 10%;
            z-index: 10;
            display: flex;
            background: transparent;
        }
        
        .mode-target { 
            flex: 1; 
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-target:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .mode-target.active {
            background: rgba(255, 0, 0, 0.2);
        }

        /* 按鈕 + 按下效果 */
        .btn {
            position: absolute;
            cursor: pointer; 
            z-index: 10; 
            background: transparent;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .btn-cam { 
            bottom: 29.5%; left: 19.8%; 
            width: 3.5%; height: 5.5%;
        }
        
        .btn-run { 
            bottom: 29.5%; right: 19.8%; 
            width: 3.5%; height: 5.5%;
        }

        .btn:hover {
            background: rgba(212, 165, 116, 0.15);
        }

        .btn:active {
            transform: scale(0.95);
            background: rgba(212, 165, 116, 0.3);
        }

        /* 指示燈 */
        .light {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transition: all 0.3s;
            background: #200;
            z-index: 10;
        }
        .light-left { bottom: 22%; left: 15%; }      /* 紅燈：更靠近 MODE 字母 */
        .light-right { bottom: 22%; right: 15%; }    /* 綠燈：更靠近 LIVE EEG 字母 */
        .light.active-red { 
            background: #f00; 
            box-shadow: 0 0 12px #f00, 0 0 20px #f00;
            animation: blink 1s infinite;
        }
        .light.active-green { 
            background: #0f8; 
            box-shadow: 0 0 12px #0f8;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* 螢幕內文字 */
        .ui-text {
            position: absolute;
            padding: 12px;
            font-size: 10px;
            pointer-events: none;
            z-index: 4;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--glow-color);
        }
        .ui-top-left { top: 0; left: 0; }
        .ui-bottom-right { bottom: 0; right: 0; text-align: right; opacity: 0.8; }

        #videoElement { display: none; }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--glow-color);
            padding: 4px 8px;
            font-size: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            white-space: nowrap;
            color: var(--glow-bright);
        }
    </style>
</head>
<body>

    <div class="machine-wrapper">
        <div class="screen-container">
            <div class="ui-text ui-top-left">
                <div id="disp-mode">MODE: MIRROR_STAGE</div>
                <div id="disp-status">SYS: STANDBY</div>
            </div>
            <div class="ui-text ui-bottom-right" id="log-stream">
                AWAITING DATA...
            </div>
            <canvas id="mainCanvas"></canvas>
            <div class="crt-overlay"></div>
        </div>

        <!-- 左側旋鈕（碎片密度） -->
        <div class="knob-container knob-left">
            <div class="knob-area" id="knobDensity"></div>
            <div class="knob-value" id="valDensity">20</div>
        </div>

        <!-- 右側旋鈕（變形強度） -->
        <div class="knob-container knob-right">
            <div class="knob-area" id="knobDistort"></div>
            <div class="knob-value" id="valDistort">70%</div>
        </div>
        
        <!-- 模式選擇器 -->
        <div class="mode-selector">
            <div class="mode-target" onclick="setMode(1)"></div>
            <div class="mode-target" onclick="setMode(2)"></div>
            <div class="mode-target" onclick="setMode(3)"></div>
        </div>

        <!-- 按鈕 -->
        <div class="btn btn-cam" id="btnCam"></div>
        <div class="btn btn-run" id="btnRun"></div>

        <!-- 指示燈 -->
        <div class="light light-left" id="indRed"></div>
        <div class="light light-right" id="indGreen"></div>

        <div id="valTip" class="tooltip"></div>
    </div>

    <video id="videoElement" autoplay playsinline></video>

    <!-- 音效（需要上傳） -->
    <audio id="sndClick" preload="auto"><source src="sounds/click.mp3"></audio>
    <audio id="sndKnob" preload="auto"><source src="sounds/knob.mp3"></audio>
    <audio id="sndMode" preload="auto"><source src="sounds/mode.mp3"></audio>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('videoElement');
        const tip = document.getElementById('valTip');
        
        const captureCanvas = document.createElement('canvas');
        const captureCtx = captureCanvas.getContext('2d');
        
        // 音效
        const sounds = {
            click: document.getElementById('sndClick'),
            knob: document.getElementById('sndKnob'),
            mode: document.getElementById('sndMode')
        };

        const state = {
            isRunning: false,
            cameraActive: false,
            currentMode: 1,
            density: 28,
            distortion: 0.7,
            frameCount: 0,
            scanProgress: 0,
            facialFragments: [],
            facialDatabase: {
                eyes: [],
                ears: [],
                nose: [],
                mouth: [],
                skin: []
            },
            databaseReady: false,
            useExternalImages: false,
            faceCenter: { x: 0.5, y: 0.45 },
            faceSize: { w: 0.35, h: 0.45 },
            lastReshuffleTime: 0,
            reshuffleSpeed: 3.0
        };

        // ==================== 外部圖片載入（可選） ====================
        async function loadExternalImages() {
            addLog("LOADING EXTERNAL DB...");
            
            state.facialDatabase = {
                eyes: [],
                ears: [],
                nose: [],
                mouth: [],
                skin: []
            };
            
            const parts = ['eyes', 'ears', 'nose', 'mouth', 'skin'];
            
            for (const part of parts) {
                for (let i = 1; i <= 50; i++) {
                    try {
                        const img = new Image();
                        const filename = `facial-parts/${part}/${part}_${String(i).padStart(2, '0')}.png`;
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                state.facialDatabase[part].push(canvas);
                                resolve();
                            };
                            img.onerror = () => resolve();
                            img.src = filename;
                        });
                    } catch (e) {
                        console.log(`Skip ${part}_${i}`);
                    }
                }
                addLog(`${part.toUpperCase()}: ${state.facialDatabase[part].length}`);
            }
            
            const totalLoaded = state.facialDatabase.eyes.length + 
                              state.facialDatabase.ears.length + 
                              state.facialDatabase.nose.length + 
                              state.facialDatabase.mouth.length + 
                              state.facialDatabase.skin.length;
            
            if (totalLoaded > 0) {
                state.databaseReady = true;
                state.useExternalImages = true;
                addLog("EXTERNAL DB READY");
                addLog(`TOTAL: ${totalLoaded} images`);
                setTimeout(() => {
                    captureFacialFragments();
                }, 500);
            } else {
                addLog("NO EXTERNAL IMAGES");
                addLog("USING AUTO-BUILD");
                buildFacialDatabase();
            }
        }

        function init() {
            resize();
            captureCanvas.width = 640;
            captureCanvas.height = 480;
            setupEvents();
            requestAnimationFrame(loop);
            addLog("CORE LINK READY.");
            
            window.addEventListener('orientationchange', handleOrientationChange);
            handleOrientationChange();
        }
        
        function handleOrientationChange() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isMobile && isPortrait) {
                addLog("ROTATE TO LANDSCAPE");
            } else if (isMobile) {
                addLog("LANDSCAPE MODE OK");
                setTimeout(resize, 100);
            }
        }

        function setupEvents() {
            document.getElementById('btnCam').onclick = () => {
                playSound('click');
                toggleCamera();
            };
            
            document.getElementById('btnRun').onclick = () => {
                playSound('click');
                toggleSystem();
            };
            
            setupKnob('knobDensity', (val) => {
                state.density = Math.floor(8 + val * 24);
                document.getElementById('valDensity').textContent = state.density;
                playSound('knob');
                if (state.currentMode === 3 && state.databaseReady && state.isRunning) {
                    captureFacialFragments();
                }
            });
            
            setupKnob('knobDistort', (val) => {
                state.distortion = val;
                document.getElementById('valDistort').textContent = Math.floor(val*100) + '%';
                playSound('knob');
            });

            window.addEventListener('resize', resize);
        }

        function playSound(name) {
            if (sounds[name]) {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => {});
            }
        }

        function setupKnob(id, callback) {
            let isDragging = false;
            let lastY = 0;
            let currentVal = (id === 'knobDensity') ? 0.833 : 0.7;
            const el = document.getElementById(id);
            
            el.onmousedown = (e) => { 
                e.preventDefault();
                isDragging = true; 
                lastY = e.clientY;
                el.classList.add('active');
            };
            
            el.ontouchstart = (e) => {
                e.preventDefault();
                isDragging = true;
                lastY = e.touches[0].clientY;
                el.classList.add('active');
            };
            
            window.onmousemove = (e) => {
                if (!isDragging) return;
                let delta = (lastY - e.clientY) * 0.005;
                currentVal = Math.min(1, Math.max(0, currentVal + delta));
                lastY = e.clientY;
                callback(currentVal);
            };
            
            window.ontouchmove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                let delta = (lastY - e.touches[0].clientY) * 0.005;
                currentVal = Math.min(1, Math.max(0, currentVal + delta));
                lastY = e.touches[0].clientY;
                callback(currentVal);
            };
            
            window.onmouseup = () => { 
                isDragging = false;
                el.classList.remove('active');
            };
            
            window.ontouchend = () => {
                isDragging = false;
                el.classList.remove('active');
            };
        }

        async function toggleCamera() {
            if (!state.cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
                    });
                    video.srcObject = stream;
                    state.cameraActive = true;
                    document.getElementById('indGreen').classList.add('active-green');
                    addLog("VIDEO LINK: ON");
                } catch (e) { addLog("ERR: NO CAMERA"); }
            } else {
                const stream = video.srcObject;
                if (stream) stream.getTracks().forEach(t => t.stop());
                video.srcObject = null;
                state.cameraActive = false;
                document.getElementById('indGreen').classList.remove('active-green');
                addLog("VIDEO LINK: OFF");
            }
        }

        function toggleSystem() {
            state.isRunning = !state.isRunning;
            document.getElementById('indRed').classList.toggle('active-red', state.isRunning);
            document.getElementById('disp-status').textContent = `SYS: ${state.isRunning ? 'OBSERVING' : 'STANDBY'}`;
            addLog(state.isRunning ? "INITIATING SCAN..." : "SCAN PAUSED.");
            
            if (state.isRunning && state.currentMode === 3 && state.cameraActive) {
                if (!state.databaseReady) {
                    loadExternalImages();
                } else {
                    captureFacialFragments();
                }
            }
        }

        function setMode(m) {
            state.currentMode = m;
            const names = ["", "1_MIRROR_STAGE", "2_DATA_DISCIPLINE", "3_HYPERREAL_SIM"];
            document.getElementById('disp-mode').textContent = `MODE: ${names[m]}`;
            
            document.querySelectorAll('.mode-target').forEach((el, i) => {
                el.classList.toggle('active', i === m - 1);
            });
            
            playSound('mode');
            addLog(`STAGE_${m} ACTIVATED.`);
            
            if (m === 3 && state.cameraActive && state.isRunning) {
                if (!state.databaseReady) {
                    loadExternalImages();
                } else {
                    captureFacialFragments();
                }
            }
        }

        // ==================== 臉部檢測 ====================
        function detectFaceCenter() {
            if (!video.readyState || video.readyState < 2) return;
            
            captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
            const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
            const data = imageData.data;
            
            let maxBrightness = 0;
            let brightX = captureCanvas.width * 0.5;
            let brightY = captureCanvas.height * 0.45;
            
            const sampleSize = 20;
            for (let y = 100; y < captureCanvas.height - 100; y += sampleSize) {
                for (let x = 100; x < captureCanvas.width - 100; x += sampleSize) {
                    let brightness = 0, count = 0;
                    
                    for (let dy = 0; dy < sampleSize; dy++) {
                        for (let dx = 0; dx < sampleSize; dx++) {
                            const index = ((y + dy) * captureCanvas.width + (x + dx)) * 4;
                            brightness += (data[index] + data[index + 1] + data[index + 2]) / 3;
                            count++;
                        }
                    }
                    
                    brightness /= count;
                    if (brightness > maxBrightness) {
                        maxBrightness = brightness;
                        brightX = x + sampleSize / 2;
                        brightY = y + sampleSize / 2;
                    }
                }
            }
            
            state.faceCenter.x = brightX / captureCanvas.width;
            state.faceCenter.y = brightY / captureCanvas.height;
        }

        // ==================== 建立五官資料庫 ====================
        async function buildFacialDatabase() {
            if (!video.readyState || video.readyState < 2) return;
            
            addLog("BUILDING DATABASE...");
            
            state.facialDatabase = {
                eyes: [],
                ears: [],
                nose: [],
                mouth: [],
                skin: []
            };
            
            for (let frame = 0; frame < 20; frame++) {
                await new Promise(resolve => setTimeout(resolve, 100));
                
                detectFaceCenter();
                
                captureCtx.save();
                captureCtx.scale(-1, 1);
                captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.restore();
                
                const faceCenterX = state.faceCenter.x * captureCanvas.width;
                const faceCenterY = state.faceCenter.y * captureCanvas.height;
                const faceWidth = state.faceSize.w * captureCanvas.width;
                const faceHeight = state.faceSize.h * captureCanvas.height;
                
                const positions = {
                    eyes: { x: 0, y: -0.15, w: 0.5, h: 0.2 },
                    ears: { x: 0, y: 0, w: 0.6, h: 0.4 },
                    nose: { x: 0, y: 0.1, w: 0.25, h: 0.3 },
                    mouth: { x: 0, y: 0.35, w: 0.4, h: 0.2 },
                    skin: { x: 0, y: 0, w: 0.6, h: 0.6 }
                };
                
                for (const [part, pos] of Object.entries(positions)) {
                    const partWidth = faceWidth * pos.w;
                    const partHeight = faceHeight * pos.h;
                    
                    const sourceX = Math.max(0, Math.min(
                        captureCanvas.width - partWidth,
                        faceCenterX + pos.x * faceWidth - partWidth / 2
                    ));
                    const sourceY = Math.max(0, Math.min(
                        captureCanvas.height - partHeight,
                        faceCenterY + pos.y * faceHeight - partHeight / 2
                    ));
                    
                    const partCanvas = document.createElement('canvas');
                    partCanvas.width = partWidth;
                    partCanvas.height = partHeight;
                    const partCtx = partCanvas.getContext('2d');
                    
                    partCtx.drawImage(
                        captureCanvas,
                        sourceX, sourceY, partWidth, partHeight,
                        0, 0, partWidth, partHeight
                    );
                    
                    state.facialDatabase[part].push(partCanvas);
                }
            }
            
            state.databaseReady = true;
            addLog(`DATABASE READY`);
            addLog(`EYES: ${state.facialDatabase.eyes.length}`);
            addLog(`NOSE: ${state.facialDatabase.nose.length}`);
            addLog(`MOUTH: ${state.facialDatabase.mouth.length}`);
            
            setTimeout(() => {
                captureFacialFragments();
            }, 500);
        }

        // ==================== 五官拼貼碎片生成（加入 3D 座標） ====================
        function captureFacialFragments() {
            if (!state.databaseReady) return;
            if (canvas.width === 0 || canvas.height === 0) {
                addLog("CANVAS NOT READY");
                return;
            }
            
            state.facialFragments = [];
            
            const availableParts = [];
            if (state.facialDatabase.eyes.length > 0) availableParts.push('eyes');
            if (state.facialDatabase.ears.length > 0) availableParts.push('ears');
            if (state.facialDatabase.nose.length > 0) availableParts.push('nose');
            if (state.facialDatabase.mouth.length > 0) availableParts.push('mouth');
            if (state.facialDatabase.skin.length > 0) availableParts.push('skin');
            
            if (availableParts.length === 0) {
                addLog("NO PARTS AVAILABLE");
                return;
            }
            
            for (let i = 0; i < state.density; i++) {
                const partType = availableParts[Math.floor(Math.random() * availableParts.length)];
                const partArray = state.facialDatabase[partType];
                const partCanvas = partArray[Math.floor(Math.random() * partArray.length)];
                
                const transform = {
                    flipH: Math.random() > 0.7,
                    flipV: Math.random() > 0.85,
                    rotate: (Math.random() - 0.5) * 30,
                    scaleX: 0.7 + Math.random() * 0.6,
                    scaleY: 0.7 + Math.random() * 0.6
                };
                
                const baseAngle = (i / state.density) * Math.PI * 2;
                const angleOffset = (Math.random() - 0.5) * (Math.PI / state.density);
                const angle = baseAngle + angleOffset;
                const radius = 100 + Math.random() * 80;
                const startX = canvas.width/2 + Math.cos(angle) * radius;
                const startY = canvas.height/2 + Math.sin(angle) * radius;
                
                // **新增：3D 座標系統**
                state.facialFragments.push({
                    canvas: partCanvas,
                    width: partCanvas.width,
                    height: partCanvas.height,
                    partType,
                    transform,
                    // 2D 位置
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 1,
                    vy: (Math.random() - 0.5) * 1,
                    // **3D 深度座標（Z 軸）**
                    z: Math.random() * 300 - 150,  // -150 到 +150（前後浮動）
                    vz: (Math.random() - 0.5) * 0.5,  // Z 軸速度
                    // 3D 旋轉角度
                    rotateX: (Math.random() - 0.5) * 60,  // X 軸旋轉 -30° 到 +30°
                    rotateY: (Math.random() - 0.5) * 60,  // Y 軸旋轉
                    rotateZ: (Math.random() - 0.5) * 180, // Z 軸旋轉（原本的 rotate）
                    rotationSpeedX: (Math.random() - 0.5) * 0.3,
                    rotationSpeedY: (Math.random() - 0.5) * 0.3,
                    rotationSpeedZ: (Math.random() - 0.5) * 0.3,
                    alpha: 0.8 + Math.random() * 0.2,
                    zIndex: Math.random(),
                    depth: 0
                });
            }
            
            state.facialFragments.sort((a, b) => a.zIndex - b.zIndex);
            state.lastReshuffleTime = performance.now();
            addLog(`FRAGMENTS: ${state.facialFragments.length}`);
            addLog(`PARTS: ${availableParts.join(',')}`);
        }

        function addLog(msg) {
            const el = document.getElementById('log-stream');
            const lines = el.innerHTML.split('<br>');
            el.innerHTML = msg + "<br>" + lines.slice(0, 2).join('<br>');
        }

        function resize() {
            const container = document.querySelector('.screen-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }

        function loop(timestamp) {
            if (state.isRunning && state.cameraActive && video.readyState >= 2) {
                state.frameCount++;
                
                if (state.currentMode === 1 || state.currentMode === 2) {
                    detectFaceCenter();
                }
                
                if (state.currentMode === 3) {
                    detectFaceCenter();
                    
                    if (timestamp - state.lastReshuffleTime > 10000 && state.databaseReady) {
                        captureFacialFragments();
                        state.lastReshuffleTime = timestamp;
                    }
                }
                
                render();
            }
            requestAnimationFrame(loop);
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function render() {
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            if (state.currentMode === 1) {
                // 階段1：掃描 + 人臉鎖定
                ctx.globalAlpha = 0.3;
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                state.scanProgress = (state.scanProgress + 2) % h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, state.scanProgress);
                ctx.lineTo(w, state.scanProgress);
                ctx.stroke();
                
                const gradient = ctx.createLinearGradient(0, state.scanProgress - 50, 0, state.scanProgress + 50);
                gradient.addColorStop(0, 'rgba(212, 165, 116, 0)');
                gradient.addColorStop(0.5, 'rgba(212, 165, 116, 0.2)');
                gradient.addColorStop(1, 'rgba(212, 165, 116, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, state.scanProgress - 50, w, 100);
                
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                const faceWidth = state.faceSize.w * w;
                const faceHeight = state.faceSize.h * h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.9)';
                ctx.lineWidth = 2;
                ctx.strokeRect(faceCenterX - faceWidth/2, faceCenterY - faceHeight/2, faceWidth, faceHeight);
                
                const cornerSize = 20;
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(faceCenterX - faceWidth/2, faceCenterY - faceHeight/2 + cornerSize);
                ctx.lineTo(faceCenterX - faceWidth/2, faceCenterY - faceHeight/2);
                ctx.lineTo(faceCenterX - faceWidth/2 + cornerSize, faceCenterY - faceHeight/2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(faceCenterX + faceWidth/2 - cornerSize, faceCenterY - faceHeight/2);
                ctx.lineTo(faceCenterX + faceWidth/2, faceCenterY - faceHeight/2);
                ctx.lineTo(faceCenterX + faceWidth/2, faceCenterY - faceHeight/2 + cornerSize);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(faceCenterX - faceWidth/2, faceCenterY + faceHeight/2 - cornerSize);
                ctx.lineTo(faceCenterX - faceWidth/2, faceCenterY + faceHeight/2);
                ctx.lineTo(faceCenterX - faceWidth/2 + cornerSize, faceCenterY + faceHeight/2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(faceCenterX + faceWidth/2 - cornerSize, faceCenterY + faceHeight/2);
                ctx.lineTo(faceCenterX + faceWidth/2, faceCenterY + faceHeight/2);
                ctx.lineTo(faceCenterX + faceWidth/2, faceCenterY + faceHeight/2 - cornerSize);
                ctx.stroke();
                
            } else if (state.currentMode === 2) {
                // 階段2：色彩
                captureCtx.save();
                captureCtx.scale(-1, 1);
                captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.restore();
                
                const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
                const data = imageData.data;
                const time = performance.now() * 0.0012;
                const pixelSize = 15;
                const cols = Math.ceil(captureCanvas.width / pixelSize);
                const rows = Math.ceil(captureCanvas.height / pixelSize);
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        
                        for (let py = 0; py < pixelSize; py++) {
                            for (let px = 0; px < pixelSize; px++) {
                                const sourceX = x * pixelSize + px;
                                const sourceY = y * pixelSize + py;
                                if (sourceX < captureCanvas.width && sourceY < captureCanvas.height) {
                                    const index = (sourceY * captureCanvas.width + sourceX) * 4;
                                    r += data[index]; 
                                    g += data[index + 1]; 
                                    b += data[index + 2];
                                    count++;
                                }
                            }
                        }
                        
                        if (count > 0) {
                            r = Math.floor(r / count); 
                            g = Math.floor(g / count); 
                            b = Math.floor(b / count);
                            
                            const hsl = rgbToHsl(r, g, b);
                            hsl.h = (hsl.h + time * 50 + x * 10 + y * 10) % 360;
                            hsl.s = Math.max(0, Math.min(100, hsl.s + Math.sin(time + x * 0.1) * 30));
                            hsl.l = Math.max(0, Math.min(100, hsl.l + Math.cos(time + y * 0.1) * 20));
                            
                            const drawX = (x * pixelSize) * (w / captureCanvas.width);
                            const drawY = (y * pixelSize) * (h / captureCanvas.height);
                            const drawSize = pixelSize * (w / captureCanvas.width);
                            
                            ctx.fillStyle = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
                            ctx.fillRect(drawX, drawY, drawSize, drawSize);
                        }
                    }
                }
                
            } else if (state.currentMode === 3) {
                // ==================== 階段3：3D 立體五官碎片 ====================
                
                // 背景人像（保持原樣）
                ctx.globalAlpha = 0.6;
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                if (state.facialFragments.length === 0) {
                    ctx.fillStyle = 'rgba(212, 165, 116, 0.8)';
                    ctx.font = '14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('WAITING FOR FRAGMENTS...', w/2, h/2);
                    ctx.fillText(`DB READY: ${state.databaseReady}`, w/2, h/2 + 20);
                    ctx.fillText(`CANVAS: ${canvas.width}x${canvas.height}`, w/2, h/2 + 40);
                    return;
                }
                
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                
                // **更新所有碎片的 3D 運動**
                state.facialFragments.forEach(frag => {
                    // 計算 XY 平面距離（用於吸引/推離力）
                    const dx = faceCenterX - frag.x;
                    const dy = faceCenterY - frag.y;
                    const xyDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    // **1. XY 平面磁性運動（保持原邏輯）**
                    const targetDistance = 100;
                    
                    if (xyDistance > targetDistance + 20) {
                        const attractionStrength = 0.05;
                        const pull = (xyDistance - targetDistance) / 200;
                        frag.vx += (dx / xyDistance) * attractionStrength * pull;
                        frag.vy += (dy / xyDistance) * attractionStrength * pull;
                    } else if (xyDistance < targetDistance - 20) {
                        const repulsionStrength = 0.02;
                        frag.vx -= (dx / xyDistance) * repulsionStrength;
                        frag.vy -= (dy / xyDistance) * repulsionStrength;
                    } else {
                        const orbitStrength = 0.01;
                        frag.vx += -dy / xyDistance * orbitStrength;
                        frag.vy += dx / xyDistance * orbitStrength;
                    }
                    
                    // **2. Z 軸深度運動（新增）**
                    // Z 軸在 -150 到 +150 之間浮動
                    if (frag.z > 150) {
                        frag.vz -= 0.05;  // 太遠則往回拉
                    } else if (frag.z < -150) {
                        frag.vz += 0.05;  // 太近則往外推
                    } else {
                        // 在正常範圍內，隨機漂浮
                        frag.vz += (Math.random() - 0.5) * 0.1;
                    }
                    
                    // Z 軸速度阻尼
                    frag.vz *= 0.95;
                    
                    // 限制 Z 軸速度
                    frag.vz = Math.max(-2, Math.min(2, frag.vz));
                    
                    // 更新 Z 座標
                    frag.z += frag.vz;
                    
                    // **3. XY 速度阻尼和擾動（保持原邏輯）**
                    frag.vx *= 0.95;
                    frag.vy *= 0.95;
                    
                    frag.vx += (Math.random() - 0.5) * 0.1;
                    frag.vy += (Math.random() - 0.5) * 0.1;
                    
                    const maxSpeed = 2;
                    const speed = Math.sqrt(frag.vx * frag.vx + frag.vy * frag.vy);
                    if (speed > maxSpeed) {
                        frag.vx = (frag.vx / speed) * maxSpeed;
                        frag.vy = (frag.vy / speed) * maxSpeed;
                    }
                    
                    // 更新 XY 位置
                    frag.x += frag.vx;
                    frag.y += frag.vy;
                    
                    // 邊界處理
                    const margin = 30;
                    if (frag.x < margin) { frag.vx += 0.3; frag.x = margin; }
                    if (frag.x > w - margin) { frag.vx -= 0.3; frag.x = w - margin; }
                    if (frag.y < margin) { frag.vy += 0.3; frag.y = margin; }
                    if (frag.y > h - margin) { frag.vy -= 0.3; frag.y = h - margin; }
                    
                    // **4. 3D 旋轉更新**
                    frag.rotateX += frag.rotationSpeedX;
                    frag.rotateY += frag.rotationSpeedY;
                    frag.rotateZ += frag.rotationSpeedZ;
                    
                    // **5. 計算總深度（用於排序和透視）**
                    frag.depth = xyDistance + Math.abs(frag.z);
                });
                
                // **根據深度排序（遠的先畫）**
                state.facialFragments.sort((a, b) => (b.depth + b.z) - (a.depth + a.z));
                
                // **繪製所有碎片（3D 效果）**
                state.facialFragments.forEach(frag => {
                    ctx.save();
                    
                    // **透視投影參數**
                    const focalLength = 500;  // 焦距（越小透視越強）
                    const perspective = focalLength / (focalLength + frag.z);
                    
                    // **投影後的位置**
                    const projectedX = frag.x;
                    const projectedY = frag.y;
                    
                    ctx.translate(projectedX, projectedY);
                    
                    // **3D 旋轉模擬（使用 skew 和 scale）**
                    const radX = frag.rotateX * Math.PI / 180;
                    const radY = frag.rotateY * Math.PI / 180;
                    const radZ = frag.rotateZ * Math.PI / 180;
                    
                    // Y 軸旋轉效果（左右傾斜）
                    const skewX = Math.tan(radY) * 0.5;
                    const scaleXFromY = Math.abs(Math.cos(radY));
                    
                    // X 軸旋轉效果（上下傾斜）
                    const skewY = Math.tan(radX) * 0.5;
                    const scaleYFromX = Math.abs(Math.cos(radX));
                    
                    // Z 軸旋轉（平面旋轉）
                    ctx.rotate(radZ);
                    
                    // 應用 3D 效果
                    ctx.transform(
                        scaleXFromY, skewY,
                        skewX, scaleYFromX,
                        0, 0
                    );
                    
                    // **透視縮放**
                    let scaleX = frag.transform.scaleX * perspective;
                    let scaleY = frag.transform.scaleY * perspective;
                    if (frag.transform.flipH) scaleX *= -1;
                    if (frag.transform.flipV) scaleY *= -1;
                    
                    ctx.scale(scaleX, scaleY);
                    
                    // **碎片大小（縮小到一半）**
                    const displayWidth = frag.width * (w / captureCanvas.width) * 0.5;
                    const displayHeight = frag.height * (h / captureCanvas.height) * 0.5;
                    
                    // **深度比例（用於光影效果）**
                    const depthRatio = Math.max(0, Math.min(1, (frag.z + 150) / 300));  // 0（近）到 1（遠）
                    
                    // **1. 深層陰影（3D 立體感）**
                    const shadowOffset = 15 * (1 - depthRatio);
                    const shadowBlur = 25 * (1 - depthRatio);
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = shadowBlur;
                    ctx.shadowOffsetX = shadowOffset;
                    ctx.shadowOffsetY = shadowOffset;
                    
                    // **2. 繪製五官碎片（根據深度調整透明度）**
                    const alphaByDepth = frag.alpha * (1 - depthRatio * 0.5);  // 遠的更透明
                    ctx.globalAlpha = alphaByDepth;
                    ctx.drawImage(frag.canvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    // 重置陰影
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    // **3. 玻璃邊框（雙層）**
                    ctx.globalAlpha = 0.6 * (1 - depthRatio * 0.3);
                    ctx.strokeStyle = `rgba(${150 + depthRatio * 50}, ${120 + depthRatio * 30}, 80, 0.8)`;
                    ctx.lineWidth = 2.5;
                    ctx.strokeRect(-displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    ctx.globalAlpha = 0.4 * (1 - depthRatio * 0.3);
                    ctx.strokeStyle = 'rgba(255, 220, 180, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-displayWidth / 2 + 1, -displayHeight / 2 + 1, displayWidth - 2, displayHeight - 2);
                    
                    // **4. 玻璃高光（根據 3D 角度調整）**
                    // 左上角主高光
                    const glareIntensity = (1 - depthRatio * 0.6) * (0.5 + Math.abs(Math.sin(radY)) * 0.5);
                    const glareGradient = ctx.createLinearGradient(
                        -displayWidth / 2, -displayHeight / 2,
                        -displayWidth / 2 + displayWidth * 0.4, -displayHeight / 2 + displayHeight * 0.4
                    );
                    glareGradient.addColorStop(0, `rgba(255, 255, 255, ${0.7 * glareIntensity})`);
                    glareGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.3 * glareIntensity})`);
                    glareGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.globalAlpha = 0.6 * glareIntensity;
                    ctx.fillStyle = glareGradient;
                    ctx.fillRect(-displayWidth / 2, -displayHeight / 2, displayWidth * 0.4, displayHeight * 0.4);
                    
                    // 右下角次要高光
                    const glare2Intensity = (1 - depthRatio * 0.6) * (0.3 + Math.abs(Math.sin(radX)) * 0.3);
                    const glare2Gradient = ctx.createLinearGradient(
                        displayWidth / 2, displayHeight / 2,
                        displayWidth / 2 - displayWidth * 0.2, displayHeight / 2 - displayHeight * 0.2
                    );
                    glare2Gradient.addColorStop(0, `rgba(255, 255, 255, ${0.4 * glare2Intensity})`);
                    glare2Gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.globalAlpha = 0.4 * glare2Intensity;
                    ctx.fillStyle = glare2Gradient;
                    ctx.fillRect(displayWidth / 2 - displayWidth * 0.2, displayHeight / 2 - displayHeight * 0.2, displayWidth * 0.2, displayHeight * 0.2);
                    
                    ctx.restore();
                });
            }
        }
        
        window.onload = init;
    </script>
</body>
</html>
