<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自我觀測儀 | 復古實體重構版</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        :root {
            --glow-color: #0f8;
            --crt-bg: #050805;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: var(--glow-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 主容器 - 根據你設計的圖稿比例調整 */
        .machine-wrapper {
            position: relative;
            width: 95vw;
            max-width: 1100px;
            aspect-ratio: 1000 / 667; /* 根據圖片比例調整 */
            background-image: url('ChatGPT Image 2026年2月21日 下午03_01_42.jpg');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 100px rgba(0, 255, 136, 0.1);
        }

        /* 中央螢幕區域 - 精確定位到圖中的螢幕框 */
        .screen-container {
            position: absolute;
            top: 11.5%;
            left: 24.5%;
            width: 51%;
            height: 51.5%;
            background: var(--crt-bg);
            border-radius: 5px;
            overflow: hidden;
            z-index: 2;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            display: block;
            filter: contrast(1.1) brightness(1.1) saturate(1.2);
        }

        /* 掃描線效果疊加 */
        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 5;
        }

        .crt-flicker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            pointer-events: none;
            animation: flicker 0.15s infinite;
            z-index: 6;
        }

        @keyframes flicker {
            0% { opacity: 0.1; }
            50% { opacity: 0.02; }
            100% { opacity: 0.08; }
        }

        /* 互動旋鈕覆蓋層 (左：碎片/密度) */
        .knob-overlay-left {
            position: absolute;
            top: 13%; left: 7%;
            width: 13%; height: 20%;
            z-index: 10;
            cursor: ns-resize;
        }

        /* 互動旋鈕覆蓋層 (右：變形/強度) */
        .knob-overlay-right {
            position: absolute;
            top: 13%; right: 7%;
            width: 13%; height: 20%;
            z-index: 10;
            cursor: ns-resize;
        }

        /* 底部模式切換 (對應圖中的 MODE 滑塊區域) */
        .mode-selector {
            position: absolute;
            bottom: 19%; left: 30%;
            width: 40%; height: 8%;
            z-index: 10;
            display: flex;
            justify-content: space-around;
        }

        .mode-btn {
            width: 30%; height: 100%;
            background: transparent;
            border: none;
            cursor: pointer;
        }

        /* 實體按鈕 (左圓按鈕：攝影機) */
        .physical-btn-left {
            position: absolute;
            bottom: 30%; left: 20%;
            width: 3%; height: 4.5%;
            border-radius: 50%;
            background: transparent;
            border: none;
            cursor: pointer;
            z-index: 10;
        }

        /* 實體按鈕 (右圓按鈕：啟動/停止) */
        .physical-btn-right {
            position: absolute;
            bottom: 30%; right: 20%;
            width: 3%; height: 4.5%;
            border-radius: 50%;
            background: transparent;
            border: none;
            cursor: pointer;
            z-index: 10;
        }

        /* 螢幕內顯示數據 */
        .screen-data {
            position: absolute;
            top: 10px; left: 15px;
            font-size: 10px;
            color: var(--glow-color);
            text-shadow: 0 0 5px var(--glow-color);
            pointer-events: none;
            z-index: 10;
            text-transform: uppercase;
        }

        .log-stream {
            position: absolute;
            bottom: 10px; right: 15px;
            text-align: right;
            font-size: 9px;
            max-width: 150px;
            opacity: 0.8;
            pointer-events: none;
            z-index: 10;
        }

        /* 指示燈效果 */
        .indicator-light {
            position: absolute;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .light-rec { bottom: 22%; left: 28%; width: 8px; height: 8px; }
        .light-live { bottom: 22%; right: 28%; width: 8px; height: 8px; }

        .active-red { background: #ff0000; box-shadow: 0 0 10px #f00; }
        .active-green { background: #00ff88; box-shadow: 0 0 10px #0f8; }

        #videoElement { display: none; }
        
        .label-popup {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid var(--glow-color);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div class="machine-wrapper" id="machine">
        
        <!-- 螢幕區 -->
        <div class="screen-container">
            <div class="screen-data">
                <div id="sysMode">MODE: 1_MIRROR_STAGE</div>
                <div id="sysStatus">STATUS: STANDBY</div>
                <div id="sysLatency">LTCY: 100ms</div>
            </div>
            
            <div class="log-stream" id="logStream">
                INITIALIZING SUBJECT...
            </div>
            
            <canvas id="mainCanvas"></canvas>
            <div class="crt-overlay"></div>
            <div class="crt-flicker"></div>
        </div>

        <!-- 互動旋鈕覆蓋 (隱形但可拖動) -->
        <div class="knob-overlay-left" id="knobLeft" title="調整碎片數量"></div>
        <div class="knob-overlay-right" id="knobRight" title="調整變形強度"></div>

        <!-- 模式切換按鈕覆蓋 -->
        <div class="mode-selector">
            <button class="mode-btn" onclick="setStage(1)" title="階段 1: 鏡像"></button>
            <button class="mode-btn" onclick="setStage(2)" title="階段 2: 規訓"></button>
            <button class="mode-btn" onclick="setStage(3)" title="階段 3: 擬像"></button>
        </div>

        <!-- 圓形按鈕覆蓋 -->
        <button class="physical-btn-left" id="cameraBtn" title="電源 / 攝影機"></button>
        <button class="physical-btn-right" id="toggleBtn" title="觀測啟動 / 停止"></button>

        <!-- 指示燈 -->
        <div class="indicator-light light-rec" id="indRec"></div>
        <div class="indicator-light light-live" id="indLive"></div>

        <div id="tooltip" class="label-popup"></div>
    </div>

    <video id="videoElement" autoplay playsinline></video>

    <script>
        // ==================== 系統配置與狀態 ====================
        const config = {
            stages: {
                1: { name: "1_MIRROR_REFLEX", desc: "現象學觀看：同步性鏡像階段", color: "#00d4ff", delay: 100 },
                2: { name: "2_DATA_DISCIPLINE", desc: "權力規訓：非觀測數據化擷取", color: "#00ff88", delay: 2500 },
                3: { name: "3_HYPERREAL_SIM", desc: "超真實擬像：主體重構拼貼", color: "#ff00ff", delay: 6000 }
            }
        };

        const state = {
            isRunning: false,
            cameraActive: false,
            currentStage: 1,
            density: 20, // 由左旋鈕控制
            distortion: 0.6, // 由右旋鈕控制
            buffer: [],
            facialDatabase: [],
            video: document.getElementById('videoElement'),
            frameCount: 0
        };

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const captureCanvas = document.createElement('canvas');
        const captureCtx = captureCanvas.getContext('2d');

        // ==================== 初始化 ====================
        function init() {
            generateFacialFragments();
            setupInteractions();
            resize();
            window.addEventListener('resize', resize);
            
            // 啟動渲染循環
            requestAnimationFrame(loop);
        }

        function setupInteractions() {
            document.getElementById('cameraBtn').onclick = toggleCamera;
            document.getElementById('toggleBtn').onclick = toggleSystem;

            // 旋鈕模擬 (簡單的垂直拖拽)
            let isDraggingLeft = false;
            let isDraggingRight = false;

            document.getElementById('knobLeft').onmousedown = () => isDraggingLeft = true;
            document.getElementById('knobRight').onmousedown = () => isDraggingRight = true;
            
            window.onmouseup = () => { isDraggingLeft = false; isDraggingRight = false; };
            
            window.onmousemove = (e) => {
                if (isDraggingLeft) {
                    state.density = Math.floor(Math.min(40, Math.max(5, state.density - e.movementY * 0.2)));
                    showTooltip(e, `FRAGMENTS: ${state.density}`);
                }
                if (isDraggingRight) {
                    state.distortion = Math.min(1.0, Math.max(0.1, state.distortion - e.movementY * 0.005));
                    showTooltip(e, `DISTORTION: ${Math.floor(state.distortion * 100)}%`);
                }
            };
        }

        function showTooltip(e, text) {
            const tip = document.getElementById('tooltip');
            tip.style.left = e.pageX + 15 + 'px';
            tip.style.top = e.pageY + 'px';
            tip.style.opacity = 1;
            tip.textContent = text;
            setTimeout(() => tip.style.opacity = 0, 1000);
        }

        // ==================== 核心功能 ====================

        async function toggleCamera() {
            if (!state.cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    state.video.srcObject = stream;
                    state.cameraActive = true;
                    document.getElementById('indLive').classList.add('active-green');
                    addLog("CAMERA LINK ESTABLISHED.");
                } catch (err) {
                    addLog("CAMERA ERROR: PERMISSION DENIED.");
                }
            } else {
                const stream = state.video.srcObject;
                if (stream) stream.getTracks().forEach(track => track.stop());
                state.cameraActive = false;
                document.getElementById('indLive').classList.remove('active-green');
                addLog("CAMERA OFFLINE.");
            }
        }

        function toggleSystem() {
            state.isRunning = !state.isRunning;
            const status = state.isRunning ? "OBSERVING" : "PAUSED";
            document.getElementById('sysStatus').textContent = `STATUS: ${status}`;
            document.getElementById('indRec').classList.toggle('active-red', state.isRunning);
            addLog(`SYSTEM ${status}.`);
        }

        function setStage(s) {
            state.currentStage = s;
            const data = config.stages[s];
            document.getElementById('sysMode').textContent = `MODE: ${data.name}`;
            document.getElementById('sysLatency').textContent = `LTCY: ${data.delay}ms`;
            addLog(`TRANSITION TO ${data.name}...`);
        }

        // ==================== 五官生成庫 (v3核心) ====================
        function generateFacialFragments() {
            state.facialDatabase = [];
            for (let i = 0; i < 30; i++) {
                const fCanvas = document.createElement('canvas');
                fCanvas.width = 150; fCanvas.height = 150;
                const fCtx = fCanvas.getContext('2d');
                
                // 隨機膚色基底
                const h = 20 + Math.random() * 20;
                fCtx.fillStyle = `hsl(${h}, 40%, 60%)`;
                fCtx.fillRect(0,0,150,150);
                
                fCtx.translate(75, 75);
                const type = i % 3; // 0: eye, 1: nose, 2: mouth
                
                fCtx.strokeStyle = "rgba(0,0,0,0.6)";
                fCtx.lineWidth = 3;
                
                if (type === 0) { // 眼睛變體
                    fCtx.beginPath();
                    fCtx.ellipse(0, 0, 40, 15 + Math.random()*15, 0, 0, Math.PI*2);
                    fCtx.stroke();
                    fCtx.fillStyle = "#fff"; fCtx.fill();
                    fCtx.fillStyle = "#000"; fCtx.beginPath();
                    fCtx.arc((Math.random()-0.5)*15, 0, 12, 0, Math.PI*2); fCtx.fill();
                } else if (type === 1) { // 鼻子變體
                    fCtx.beginPath();
                    fCtx.moveTo(-10, -30); fCtx.quadraticCurveTo(20, 0, -10, 30);
                    fCtx.stroke();
                } else { // 嘴巴變體
                    fCtx.fillStyle = "rgba(180, 50, 50, 0.7)";
                    fCtx.beginPath();
                    fCtx.ellipse(0, 0, 45, 10 + Math.random()*15, 0, 0, Math.PI*2);
                    fCtx.fill(); fCtx.stroke();
                }
                state.facialDatabase.push(fCanvas);
            }
        }

        // ==================== 渲染循環 ====================
        function loop() {
            if (state.isRunning) {
                state.frameCount++;
                const stageData = config.stages[state.currentStage];
                const delayFrames = Math.floor(stageData.delay / 16);
                
                state.buffer.push(state.cameraActive ? "captured" : "simulated");
                if (state.buffer.length > delayFrames + 1) state.buffer.shift();
                
                render();
            }
            requestAnimationFrame(loop);
        }

        function render() {
            const w = canvas.width; const h = canvas.height;
            const t = performance.now() * 0.001;

            // CRT 殘影底色
            ctx.fillStyle = `rgba(5, 10, 5, ${state.currentStage === 1 ? 0.3 : 0.15})`;
            ctx.fillRect(0, 0, w, h);

            // 階段一、二的攝影機背景
            if (state.cameraActive && state.currentStage < 3) {
                ctx.save();
                if (state.currentStage === 1) {
                    ctx.translate(w, 0); ctx.scale(-1, 1);
                    ctx.globalAlpha = 0.5;
                } else {
                    ctx.globalAlpha = 0.2;
                    ctx.filter = "grayscale(1) contrast(1.5)";
                }
                ctx.drawImage(state.video, 0, 0, w, h);
                ctx.restore();
            }

            ctx.save();
            ctx.translate(w/2, h/2);

            if (state.currentStage === 1) {
                drawMirrorWave(t);
            } else if (state.currentStage === 2) {
                drawGridScan(w, h, t);
            } else {
                drawSimulacrum(w, h, t);
            }

            ctx.restore();
        }

        function drawMirrorWave(t) {
            ctx.strokeStyle = config.stages[1].color;
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10; ctx.shadowColor = ctx.strokeStyle;
            ctx.beginPath();
            const pts = 60;
            for(let i=0; i<=pts; i++) {
                const ang = (i/pts) * Math.PI * 2;
                const r = 100 + Math.sin(ang * 5 + t * 3) * 20;
                const x = Math.cos(ang) * r;
                const y = Math.sin(ang) * r;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.closePath(); ctx.stroke();
        }

        function drawGridScan(w, h, t) {
            const color = config.stages[2].color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5;
            for(let x=-w/2; x<w/2; x+=30) {
                ctx.beginPath(); ctx.moveTo(x, -h/2); ctx.lineTo(x, h/2); ctx.stroke();
            }
            // 掃描條
            const scanY = (Math.sin(t*1.5)*0.5+0.5) * h - h/2;
            ctx.fillStyle = "rgba(0, 255, 136, 0.2)";
            ctx.fillRect(-w/2, scanY, w, 2);
            // 特徵標籤
            ctx.fillStyle = color; ctx.font = "8px monospace";
            ctx.fillText(`SUBJ_ID: OBS_00${state.frameCount%9}`, -w/2+20, scanY-5);
        }

        function drawSimulacrum(w, h, t) {
            const rows = 4, cols = 5;
            const cellW = w/cols, cellH = h/rows;
            
            for(let i=0; i<cols; i++) {
                for(let j=0; j<rows; j++) {
                    const x = (i - cols/2 + 0.5) * cellW;
                    const y = (j - rows/2 + 0.5) * cellH;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    
                    // 根據旋鈕控制變形
                    const seed = Math.floor(Math.abs(Math.sin(i*j + Math.floor(t*state.distortion*5)) * state.facialDatabase.length));
                    const fragment = state.facialDatabase[seed % state.facialDatabase.length];
                    
                    ctx.rotate(Math.sin(t + i) * state.distortion);
                    ctx.scale(0.8, 0.8);
                    ctx.drawImage(fragment, -75, -75, 140, 140);
                    
                    // 數位邊框
                    ctx.strokeStyle = `rgba(255, 0, 255, 0.3)`;
                    ctx.strokeRect(-cellW/2+5, -cellH/2+5, cellW-10, cellH-10);
                    ctx.restore();
                }
            }
        }

        function addLog(msg) {
            const log = document.getElementById('logStream');
            log.innerHTML = msg + "<br>" + log.innerHTML.split('<br>').slice(0, 4).join('<br>');
        }

        function resize() {
            const sc = document.querySelector('.screen-container');
            canvas.width = sc.clientWidth;
            canvas.height = sc.clientHeight;
            captureCanvas.width = 640;
            captureCanvas.height = 480;
        }

        window.onload = init;
    </script>
</body>
</html>
