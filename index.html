<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自我觀測儀 | 完整版</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        :root {
            --glow-color: #d4a574;     /* 復古琥珀黃 */
            --glow-bright: #e8c891;    /* 亮琥珀黃 */
            --crt-bg: #050805;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: var(--glow-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .machine-wrapper {
            position: relative;
            width: 95vw;
            max-width: 1000px;
            aspect-ratio: 1000 / 667; 
            background-color: #1a1a1a;
            background-image: url('Image.png'); 
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 100px rgba(212, 165, 116, 0.1);
        }

        /* 螢幕區域 - 完美對齊 */
        .screen-container {
            position: absolute;
            top: 8.5%;
            left: 25.5%;    /* 往右移（內縮左邊） */
            width: 49%;     /* 縮小寬度（內縮左右） */
            height: 54%;
            background: var(--crt-bg);
            border-radius: 4px;
            overflow: hidden;
            z-index: 2;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.05), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.05));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* 旋鈕 + 數值顯示 */
        .knob-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .knob-left { 
            top: 8%; left: 6.5%; 
            width: 15%; height: 25%;
        }
        
        .knob-right { 
            top: 8%; right: 6.5%; 
            width: 15%; height: 25%;
        }

        .knob-area {
            width: 100%;
            height: 85%;
            cursor: ns-resize; 
            background: transparent;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .knob-area:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .knob-area.active {
            background: rgba(212, 165, 116, 0.2);
            box-shadow: 0 0 15px rgba(212, 165, 116, 0.5);
        }

        .knob-value {
            margin-top: 5%;
            font-size: clamp(9px, 1vw, 11px);
            color: var(--glow-bright);
            text-shadow: 0 0 8px var(--glow-color);
            text-align: center;
            font-weight: bold;
        }

        /* 模式選擇器 */
        .mode-selector {
            position: absolute;
            bottom: 16%; left: 28%;
            width: 44%; height: 10%;
            z-index: 10;
            display: flex;
            background: transparent;
        }
        
        .mode-target { 
            flex: 1; 
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-target:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .mode-target.active {
            background: rgba(255, 0, 0, 0.2);
        }

        /* 按鈕 + 按下效果 */
        .btn {
            position: absolute;
            cursor: pointer; 
            z-index: 10; 
            background: transparent;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .btn-cam { 
            bottom: 29.5%; left: 19.8%; 
            width: 3.5%; height: 5.5%;
        }
        
        .btn-run { 
            bottom: 29.5%; right: 19.8%; 
            width: 3.5%; height: 5.5%;
        }

        .btn:hover {
            background: rgba(212, 165, 116, 0.15);
        }

        .btn:active {
            transform: scale(0.95);
            background: rgba(212, 165, 116, 0.3);
        }

        /* 指示燈 */
        .light {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transition: all 0.3s;
            background: #200;
            z-index: 10;
        }
        .light-left { bottom: 22.2%; left: 29%; }      /* 精確對準左側金屬點 */
        .light-right { bottom: 22.2%; right: 29%; }    /* 精確對準右側金屬點 */
        .light.active-red { 
            background: #f00; 
            box-shadow: 0 0 12px #f00, 0 0 20px #f00;
            animation: blink 1s infinite;
        }
        .light.active-green { 
            background: #0f8; 
            box-shadow: 0 0 12px #0f8;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* 螢幕內文字 */
        .ui-text {
            position: absolute;
            padding: 12px;
            font-size: 10px;
            pointer-events: none;
            z-index: 4;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--glow-color);
        }
        .ui-top-left { top: 0; left: 0; }
        .ui-bottom-right { bottom: 0; right: 0; text-align: right; opacity: 0.8; }

        #videoElement { display: none; }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--glow-color);
            padding: 4px 8px;
            font-size: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            white-space: nowrap;
            color: var(--glow-bright);
        }
    </style>
</head>
<body>

    <div class="machine-wrapper">
        <div class="screen-container">
            <div class="ui-text ui-top-left">
                <div id="disp-mode">MODE: MIRROR_STAGE</div>
                <div id="disp-status">SYS: STANDBY</div>
            </div>
            <div class="ui-text ui-bottom-right" id="log-stream">
                AWAITING DATA...
            </div>
            <canvas id="mainCanvas"></canvas>
            <div class="crt-overlay"></div>
        </div>

        <!-- 左側旋鈕（碎片密度） -->
        <div class="knob-container knob-left">
            <div class="knob-area" id="knobDensity"></div>
            <div class="knob-value" id="valDensity">20</div>
        </div>

        <!-- 右側旋鈕（變形強度） -->
        <div class="knob-container knob-right">
            <div class="knob-area" id="knobDistort"></div>
            <div class="knob-value" id="valDistort">70%</div>
        </div>
        
        <!-- 模式選擇器 -->
        <div class="mode-selector">
            <div class="mode-target" onclick="setMode(1)"></div>
            <div class="mode-target" onclick="setMode(2)"></div>
            <div class="mode-target" onclick="setMode(3)"></div>
        </div>

        <!-- 按鈕 -->
        <div class="btn btn-cam" id="btnCam"></div>
        <div class="btn btn-run" id="btnRun"></div>

        <!-- 指示燈 -->
        <div class="light light-left" id="indRed"></div>
        <div class="light light-right" id="indGreen"></div>

        <div id="valTip" class="tooltip"></div>
    </div>

    <video id="videoElement" autoplay playsinline></video>

    <!-- 音效（需要上傳） -->
    <audio id="sndClick" preload="auto"><source src="sounds/click.mp3"></audio>
    <audio id="sndKnob" preload="auto"><source src="sounds/knob.mp3"></audio>
    <audio id="sndMode" preload="auto"><source src="sounds/mode.mp3"></audio>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('videoElement');
        const tip = document.getElementById('valTip');
        
        const captureCanvas = document.createElement('canvas');
        const captureCtx = captureCanvas.getContext('2d');
        
        // 音效
        const sounds = {
            click: document.getElementById('sndClick'),
            knob: document.getElementById('sndKnob'),
            mode: document.getElementById('sndMode')
        };

        const state = {
            isRunning: false,
            cameraActive: false,
            currentMode: 1,
            density: 20,
            distortion: 0.7,
            frameCount: 0,
            scanProgress: 0,
            facialFragments: [], // 鏡子碎片
            faceCenter: { x: 0.5, y: 0.45 },
            faceSize: { w: 0.35, h: 0.45 },
            lastReshuffleTime: 0,
            reshuffleSpeed: 3.0
        };

        function init() {
            resize();
            captureCanvas.width = 640;
            captureCanvas.height = 480;
            setupEvents();
            requestAnimationFrame(loop);
            addLog("CORE LINK READY.");
        }

        function setupEvents() {
            document.getElementById('btnCam').onclick = () => {
                playSound('click');
                toggleCamera();
            };
            
            document.getElementById('btnRun').onclick = () => {
                playSound('click');
                toggleSystem();
            };
            
            setupKnob('knobDensity', (val) => {
                state.density = Math.floor(8 + val * 24); // 8-32 個碎片
                document.getElementById('valDensity').textContent = state.density;
                playSound('knob');
            });
            
            setupKnob('knobDistort', (val) => {
                state.distortion = val;
                document.getElementById('valDistort').textContent = Math.floor(val*100) + '%';
                playSound('knob');
            });

            window.addEventListener('resize', resize);
        }

        function playSound(name) {
            if (sounds[name]) {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => {});
            }
        }

        function setupKnob(id, callback) {
            let isDragging = false;
            let lastY = 0;
            let currentVal = (id === 'knobDensity') ? 0.5 : 0.7;
            const el = document.getElementById(id);
            
            el.onmousedown = (e) => { 
                isDragging = true; 
                lastY = e.clientY;
                el.classList.add('active');
            };
            
            window.onmousemove = (e) => {
                if (!isDragging) return;
                let delta = (lastY - e.clientY) * 0.005;
                currentVal = Math.min(1, Math.max(0, currentVal + delta));
                lastY = e.clientY;
                callback(currentVal);
            };
            
            window.onmouseup = () => { 
                isDragging = false;
                el.classList.remove('active');
            };
        }

        async function toggleCamera() {
            if (!state.cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
                    });
                    video.srcObject = stream;
                    state.cameraActive = true;
                    document.getElementById('indGreen').classList.add('active-green');
                    addLog("VIDEO LINK: ON");
                } catch (e) { addLog("ERR: NO CAMERA"); }
            } else {
                const stream = video.srcObject;
                if (stream) stream.getTracks().forEach(t => t.stop());
                video.srcObject = null;
                state.cameraActive = false;
                document.getElementById('indGreen').classList.remove('active-green');
                addLog("VIDEO LINK: OFF");
            }
        }

        function toggleSystem() {
            state.isRunning = !state.isRunning;
            document.getElementById('indRed').classList.toggle('active-red', state.isRunning);
            document.getElementById('disp-status').textContent = `SYS: ${state.isRunning ? 'OBSERVING' : 'STANDBY'}`;
            addLog(state.isRunning ? "INITIATING SCAN..." : "SCAN PAUSED.");
            
            if (state.isRunning && state.currentMode === 3) {
                captureFacialFragments();
            }
        }

        function setMode(m) {
            state.currentMode = m;
            const names = ["", "1_MIRROR_STAGE", "2_DATA_DISCIPLINE", "3_HYPERREAL_SIM"];
            document.getElementById('disp-mode').textContent = `MODE: ${names[m]}`;
            
            document.querySelectorAll('.mode-target').forEach((el, i) => {
                el.classList.toggle('active', i === m - 1);
            });
            
            playSound('mode');
            addLog(`STAGE_${m} ACTIVATED.`);
            
            if (m === 3 && state.isRunning && state.cameraActive) {
                captureFacialFragments();
            }
        }

        // ==================== 臉部檢測 ====================
        function detectFaceCenter() {
            if (!video.readyState || video.readyState < 2) return;
            
            captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
            const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
            const data = imageData.data;
            
            let maxBrightness = 0;
            let brightX = captureCanvas.width * 0.5;
            let brightY = captureCanvas.height * 0.45;
            
            const sampleSize = 20;
            for (let y = 100; y < captureCanvas.height - 100; y += sampleSize) {
                for (let x = 100; x < captureCanvas.width - 100; x += sampleSize) {
                    let brightness = 0, count = 0;
                    
                    for (let dy = 0; dy < sampleSize; dy++) {
                        for (let dx = 0; dx < sampleSize; dx++) {
                            const index = ((y + dy) * captureCanvas.width + (x + dx)) * 4;
                            brightness += (data[index] + data[index + 1] + data[index + 2]) / 3;
                            count++;
                        }
                    }
                    
                    brightness /= count;
                    if (brightness > maxBrightness) {
                        maxBrightness = brightness;
                        brightX = x + sampleSize / 2;
                        brightY = y + sampleSize / 2;
                    }
                }
            }
            
            state.faceCenter.x = brightX / captureCanvas.width;
            state.faceCenter.y = brightY / captureCanvas.height;
        }

        // ==================== 鏡子碎片生成（自由遊走）====================
        function captureFacialFragments() {
            if (!video.readyState || video.readyState < 2) return;
            
            detectFaceCenter();
            
            captureCtx.save();
            captureCtx.scale(-1, 1);
            captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
            captureCtx.restore();
            
            state.facialFragments = [];
            
            const faceCenterX = state.faceCenter.x * captureCanvas.width;
            const faceCenterY = state.faceCenter.y * captureCanvas.height;
            const faceWidth = state.faceSize.w * captureCanvas.width;
            const faceHeight = state.faceSize.h * captureCanvas.height;
            
            // 為每個碎片創建鏡子
            for (let i = 0; i < state.density; i++) {
                // 不規則碎片大小
                const fragWidth = 60 + Math.random() * 100;   // 60-160px
                const fragHeight = 60 + Math.random() * 100;  // 60-160px
                
                // **關鍵：擷取完整臉部區域作為鏡子**
                const sourceX = Math.max(0, Math.min(
                    captureCanvas.width - fragWidth,
                    faceCenterX - fragWidth / 2 + (Math.random() - 0.5) * faceWidth * 0.5
                ));
                const sourceY = Math.max(0, Math.min(
                    captureCanvas.height - fragHeight,
                    faceCenterY - fragHeight / 2 + (Math.random() - 0.5) * faceHeight * 0.5
                ));
                
                // 創建碎片 canvas（鏡子）
                const fragCanvas = document.createElement('canvas');
                fragCanvas.width = fragWidth;
                fragCanvas.height = fragHeight;
                const fragCtx = fragCanvas.getContext('2d');
                
                // 擷取臉部區域
                fragCtx.drawImage(captureCanvas, sourceX, sourceY, fragWidth, fragHeight, 0, 0, fragWidth, fragHeight);
                
                // 隨機變形
                const transform = {
                    flipH: Math.random() > 0.7,
                    flipV: Math.random() > 0.85,
                    rotate: (Math.random() - 0.5) * 25,
                    scaleX: 0.8 + Math.random() * 0.4,
                    scaleY: 0.8 + Math.random() * 0.4
                };
                
                // **初始位置：隨機在畫面中**
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * canvas.height;
                
                // **運動系統**
                state.facialFragments.push({
                    canvas: fragCanvas,
                    width: fragWidth,
                    height: fragHeight,
                    transform,
                    // 位置與運動
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 2,      // 速度 X
                    vy: (Math.random() - 0.5) * 2,      // 速度 Y
                    rotationSpeed: (Math.random() - 0.5) * 0.5,  // 旋轉速度
                    alpha: 0.7 + Math.random() * 0.3,
                    zIndex: Math.random()
                });
            }
            
            state.facialFragments.sort((a, b) => a.zIndex - b.zIndex);
            addLog(`MIRROR FRAGS: ${state.facialFragments.length}`);
            addLog(`FLOATING MODE`);
        }

        // ==================== 更新鏡子內容（保持運動） ====================
        function updateMirrorContents() {
            if (!video.readyState || video.readyState < 2) return;
            if (state.facialFragments.length === 0) return;
            
            captureCtx.save();
            captureCtx.scale(-1, 1);
            captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
            captureCtx.restore();
            
            const faceCenterX = state.faceCenter.x * captureCanvas.width;
            const faceCenterY = state.faceCenter.y * captureCanvas.height;
            const faceWidth = state.faceSize.w * captureCanvas.width;
            const faceHeight = state.faceSize.h * captureCanvas.height;
            
            // 更新每個碎片的鏡子內容（保持原有運動狀態）
            state.facialFragments.forEach(frag => {
                const sourceX = Math.max(0, Math.min(
                    captureCanvas.width - frag.width,
                    faceCenterX - frag.width / 2 + (Math.random() - 0.5) * faceWidth * 0.5
                ));
                const sourceY = Math.max(0, Math.min(
                    captureCanvas.height - frag.height,
                    faceCenterY - frag.height / 2 + (Math.random() - 0.5) * faceHeight * 0.5
                ));
                
                const fragCtx = frag.canvas.getContext('2d');
                fragCtx.clearRect(0, 0, frag.width, frag.height);
                fragCtx.drawImage(captureCanvas, sourceX, sourceY, frag.width, frag.height, 0, 0, frag.width, frag.height);
            });
            
            addLog(`MIRRORS UPDATED`);
        }

        function addLog(msg) {
            const el = document.getElementById('log-stream');
            const lines = el.innerHTML.split('<br>');
            el.innerHTML = msg + "<br>" + lines.slice(0, 2).join('<br>');
        }

        function resize() {
            const container = document.querySelector('.screen-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }

        function loop(timestamp) {
            if (state.isRunning && state.cameraActive && video.readyState >= 2) {
                state.frameCount++;
                
                // 階段1和2：即時追蹤臉部
                if (state.currentMode === 1 || state.currentMode === 2) {
                    detectFaceCenter();
                }
                
                // 階段3：持續追蹤臉部 + 定期更新碎片內容
                if (state.currentMode === 3) {
                    detectFaceCenter();
                    
                    // 每5秒重新擷取鏡子內容（更新五官影像）
                    if (timestamp - state.lastReshuffleTime > 5000) {
                        updateMirrorContents();
                        state.lastReshuffleTime = timestamp;
                    }
                }
                
                render();
            }
            requestAnimationFrame(loop);
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function render() {
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            if (state.currentMode === 1) {
                // 階段1：掃描
                ctx.globalAlpha = 0.3;
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                state.scanProgress = (state.scanProgress + 2) % h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, state.scanProgress);
                ctx.lineTo(w, state.scanProgress);
                ctx.stroke();
                
                const gradient = ctx.createLinearGradient(0, state.scanProgress - 50, 0, state.scanProgress + 50);
                gradient.addColorStop(0, 'rgba(212, 165, 116, 0)');
                gradient.addColorStop(0.5, 'rgba(212, 165, 116, 0.2)');
                gradient.addColorStop(1, 'rgba(212, 165, 116, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, state.scanProgress - 50, w, 100);
                
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                const faceWidth = state.faceSize.w * w;
                const faceHeight = state.faceSize.h * h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(faceCenterX - faceWidth/2, faceCenterY - faceHeight/2, faceWidth, faceHeight);
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.arc(faceCenterX, faceCenterY, Math.min(faceWidth, faceHeight) * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                
            } else if (state.currentMode === 2) {
                // 階段2：色彩
                captureCtx.save();
                captureCtx.scale(-1, 1);
                captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.restore();
                
                const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
                const data = imageData.data;
                const time = performance.now() * 0.0012;
                const pixelSize = 15;
                const cols = Math.ceil(captureCanvas.width / pixelSize);
                const rows = Math.ceil(captureCanvas.height / pixelSize);
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        
                        for (let py = 0; py < pixelSize; py++) {
                            for (let px = 0; px < pixelSize; px++) {
                                const sourceX = x * pixelSize + px;
                                const sourceY = y * pixelSize + py;
                                if (sourceX < captureCanvas.width && sourceY < captureCanvas.height) {
                                    const index = (sourceY * captureCanvas.width + sourceX) * 4;
                                    r += data[index]; 
                                    g += data[index + 1]; 
                                    b += data[index + 2];
                                    count++;
                                }
                            }
                        }
                        
                        if (count > 0) {
                            r = Math.floor(r / count); 
                            g = Math.floor(g / count); 
                            b = Math.floor(b / count);
                            
                            const hsl = rgbToHsl(r, g, b);
                            hsl.h = (hsl.h + time * 50 + x * 10 + y * 10) % 360;
                            hsl.s = Math.max(0, Math.min(100, hsl.s + Math.sin(time + x * 0.1) * 30));
                            hsl.l = Math.max(0, Math.min(100, hsl.l + Math.cos(time + y * 0.1) * 20));
                            
                            const drawX = (x * pixelSize) * (w / captureCanvas.width);
                            const drawY = (y * pixelSize) * (h / captureCanvas.height);
                            const drawSize = pixelSize * (w / captureCanvas.width);
                            
                            ctx.fillStyle = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
                            ctx.fillRect(drawX, drawY, drawSize, drawSize);
                        }
                    }
                }
                
            } else if (state.currentMode === 3) {
                // 階段3：鏡子碎片自由遊走
                if (state.facialFragments.length === 0) return;
                
                // 微弱背景
                ctx.globalAlpha = 0.08;
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                // 即時臉部中心（作為吸引點）
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                
                // 更新並繪製所有碎片
                state.facialFragments.forEach(frag => {
                    // **運動更新**
                    
                    // 1. 輕微吸引力朝向臉部中心（25%強度）
                    const dx = faceCenterX - frag.x;
                    const dy = faceCenterY - frag.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 50) {  // 只在距離較遠時才吸引
                        const attractionStrength = 0.015;  // 很輕微
                        frag.vx += (dx / distance) * attractionStrength;
                        frag.vy += (dy / distance) * attractionStrength;
                    }
                    
                    // 2. 速度阻尼（防止無限加速）
                    frag.vx *= 0.98;
                    frag.vy *= 0.98;
                    
                    // 3. 隨機擾動（保持自由感）
                    frag.vx += (Math.random() - 0.5) * 0.1;
                    frag.vy += (Math.random() - 0.5) * 0.1;
                    
                    // 4. 限制速度
                    const maxSpeed = 2;
                    const speed = Math.sqrt(frag.vx * frag.vx + frag.vy * frag.vy);
                    if (speed > maxSpeed) {
                        frag.vx = (frag.vx / speed) * maxSpeed;
                        frag.vy = (frag.vy / speed) * maxSpeed;
                    }
                    
                    // 5. 更新位置
                    frag.x += frag.vx;
                    frag.y += frag.vy;
                    
                    // 6. 邊界反彈
                    if (frag.x < 0 || frag.x > w) frag.vx *= -0.8;
                    if (frag.y < 0 || frag.y > h) frag.vy *= -0.8;
                    frag.x = Math.max(0, Math.min(w, frag.x));
                    frag.y = Math.max(0, Math.min(h, frag.y));
                    
                    // 7. 旋轉更新
                    frag.transform.rotate += frag.rotationSpeed;
                    
                    // **繪製碎片**
                    ctx.save();
                    
                    ctx.translate(frag.x, frag.y);
                    ctx.rotate(frag.transform.rotate * Math.PI / 180);
                    
                    let scaleX = frag.transform.scaleX;
                    let scaleY = frag.transform.scaleY;
                    if (frag.transform.flipH) scaleX *= -1;
                    if (frag.transform.flipV) scaleY *= -1;
                    ctx.scale(scaleX, scaleY);
                    
                    ctx.globalAlpha = frag.alpha;
                    const displayWidth = frag.width * (w / captureCanvas.width);
                    const displayHeight = frag.height * (h / captureCanvas.height);
                    
                    // 繪製鏡子碎片（顯示五官）
                    ctx.drawImage(frag.canvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    // 碎片邊框
                    ctx.globalAlpha = 0.25;
                    ctx.strokeStyle = 'rgba(212, 165, 116, 0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(-displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    ctx.restore();
                });
            }
        }
        
        window.onload = init;
    </script>
</body>
</html>
