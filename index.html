<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自我觀測儀 | 完整版</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');
        
        :root {
            --glow-color: #d4a574;     /* 復古琥珀黃 */
            --glow-bright: #e8c891;    /* 亮琥珀黃 */
            --crt-bg: #050805;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: #000;
            color: var(--glow-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .machine-wrapper {
            position: relative;
            width: 95vw;
            max-width: 1000px;
            aspect-ratio: 1000 / 667; 
            background-color: #1a1a1a;
            background-image: url('Image.png'); 
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 0 100px rgba(212, 165, 116, 0.1);
        }

        /* 螢幕區域 - 完美對齊 */
        .screen-container {
            position: absolute;
            top: 8.5%;
            left: 25.5%;    /* 往右移（內縮左邊） */
            width: 49%;     /* 縮小寬度（內縮左右） */
            height: 54%;
            background: var(--crt-bg);
            border-radius: 4px;
            overflow: hidden;
            z-index: 2;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .crt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.05), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.05));
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* 旋鈕 + 數值顯示 */
        .knob-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .knob-left { 
            top: 8%; left: 6.5%; 
            width: 15%; height: 25%;
        }
        
        .knob-right { 
            top: 8%; right: 6.5%; 
            width: 15%; height: 25%;
        }

        .knob-area {
            width: 100%;
            height: 85%;
            cursor: ns-resize; 
            background: transparent;
            border-radius: 50%;
            transition: background 0.3s;
        }

        .knob-area:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .knob-area.active {
            background: rgba(212, 165, 116, 0.2);
            box-shadow: 0 0 15px rgba(212, 165, 116, 0.5);
        }

        .knob-value {
            margin-top: 5%;
            font-size: clamp(9px, 1vw, 11px);
            color: var(--glow-bright);
            text-shadow: 0 0 8px var(--glow-color);
            text-align: center;
            font-weight: bold;
        }

        /* 模式選擇器 */
        .mode-selector {
            position: absolute;
            bottom: 16%; left: 28%;
            width: 44%; height: 10%;
            z-index: 10;
            display: flex;
            background: transparent;
        }
        
        .mode-target { 
            flex: 1; 
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-target:hover {
            background: rgba(212, 165, 116, 0.1);
        }

        .mode-target.active {
            background: rgba(255, 0, 0, 0.2);
        }

        /* 按鈕 + 按下效果 */
        .btn {
            position: absolute;
            cursor: pointer; 
            z-index: 10; 
            background: transparent;
            border-radius: 50%;
            transition: all 0.15s;
        }

        .btn-cam { 
            bottom: 29.5%; left: 19.8%; 
            width: 3.5%; height: 5.5%;
        }
        
        .btn-run { 
            bottom: 29.5%; right: 19.8%; 
            width: 3.5%; height: 5.5%;
        }

        .btn:hover {
            background: rgba(212, 165, 116, 0.15);
        }

        .btn:active {
            transform: scale(0.95);
            background: rgba(212, 165, 116, 0.3);
        }

        /* 指示燈 */
        .light {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            transition: all 0.3s;
            background: #200;
            z-index: 10;
        }
        .light-left { bottom: 22%; left: 24%; }      /* 紅燈移到更靠近 MODE 文字 */
        .light-right { bottom: 22%; right: 24%; }    /* 綠燈移到更靠近 LIVE EEG 文字 */
        .light.active-red { 
            background: #f00; 
            box-shadow: 0 0 12px #f00, 0 0 20px #f00;
            animation: blink 1s infinite;
        }
        .light.active-green { 
            background: #0f8; 
            box-shadow: 0 0 12px #0f8;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* 螢幕內文字 */
        .ui-text {
            position: absolute;
            padding: 12px;
            font-size: 10px;
            pointer-events: none;
            z-index: 4;
            text-transform: uppercase;
            text-shadow: 0 0 5px var(--glow-color);
        }
        .ui-top-left { top: 0; left: 0; }
        .ui-bottom-right { bottom: 0; right: 0; text-align: right; opacity: 0.8; }

        #videoElement { display: none; }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid var(--glow-color);
            padding: 4px 8px;
            font-size: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            white-space: nowrap;
            color: var(--glow-bright);
        }
    </style>
</head>
<body>

    <div class="machine-wrapper">
        <div class="screen-container">
            <div class="ui-text ui-top-left">
                <div id="disp-mode">MODE: MIRROR_STAGE</div>
                <div id="disp-status">SYS: STANDBY</div>
            </div>
            <div class="ui-text ui-bottom-right" id="log-stream">
                AWAITING DATA...
            </div>
            <canvas id="mainCanvas"></canvas>
            <div class="crt-overlay"></div>
        </div>

        <!-- 左側旋鈕（碎片密度） -->
        <div class="knob-container knob-left">
            <div class="knob-area" id="knobDensity"></div>
            <div class="knob-value" id="valDensity">20</div>
        </div>

        <!-- 右側旋鈕（變形強度） -->
        <div class="knob-container knob-right">
            <div class="knob-area" id="knobDistort"></div>
            <div class="knob-value" id="valDistort">70%</div>
        </div>
        
        <!-- 模式選擇器 -->
        <div class="mode-selector">
            <div class="mode-target" onclick="setMode(1)"></div>
            <div class="mode-target" onclick="setMode(2)"></div>
            <div class="mode-target" onclick="setMode(3)"></div>
        </div>

        <!-- 按鈕 -->
        <div class="btn btn-cam" id="btnCam"></div>
        <div class="btn btn-run" id="btnRun"></div>

        <!-- 指示燈 -->
        <div class="light light-left" id="indRed"></div>
        <div class="light light-right" id="indGreen"></div>

        <div id="valTip" class="tooltip"></div>
    </div>

    <video id="videoElement" autoplay playsinline></video>

    <!-- 音效（需要上傳） -->
    <audio id="sndClick" preload="auto"><source src="sounds/click.mp3"></audio>
    <audio id="sndKnob" preload="auto"><source src="sounds/knob.mp3"></audio>
    <audio id="sndMode" preload="auto"><source src="sounds/mode.mp3"></audio>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('videoElement');
        const tip = document.getElementById('valTip');
        
        const captureCanvas = document.createElement('canvas');
        const captureCtx = captureCanvas.getContext('2d');
        
        // 音效
        const sounds = {
            click: document.getElementById('sndClick'),
            knob: document.getElementById('sndKnob'),
            mode: document.getElementById('sndMode')
        };

        const state = {
            isRunning: false,
            cameraActive: false,
            currentMode: 1,
            density: 20,
            distortion: 0.7,
            frameCount: 0,
            scanProgress: 0,
            facialFragments: [], // 五官拼貼碎片
            facialDatabase: {    // 五官資料庫
                eyes: [],        // 眼睛
                ears: [],        // 耳朵
                nose: [],        // 鼻子
                mouth: [],       // 嘴巴
                skin: []         // 皮膚
            },
            databaseReady: false,
            useExternalImages: false,  // 是否使用外部圖片
            faceCenter: { x: 0.5, y: 0.45 },
            faceSize: { w: 0.35, h: 0.45 },
            lastReshuffleTime: 0,
            reshuffleSpeed: 3.0
        };

        // ==================== 外部圖片載入（可選） ====================
        async function loadExternalImages() {
            addLog("LOADING EXTERNAL DB...");
            
            state.facialDatabase = {
                eyes: [],
                ears: [],
                nose: [],
                mouth: [],
                skin: []
            };
            
            const parts = ['eyes', 'ears', 'nose', 'mouth', 'skin'];
            
            for (const part of parts) {
                for (let i = 1; i <= 50; i++) {
                    try {
                        const img = new Image();
                        const filename = `facial-parts/${part}/${part}_${String(i).padStart(2, '0')}.png`;
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                state.facialDatabase[part].push(canvas);
                                resolve();
                            };
                            img.onerror = () => resolve(); // 忽略載入失敗的圖片
                            img.src = filename;
                        });
                    } catch (e) {
                        console.log(`Skip ${part}_${i}`);
                    }
                }
                addLog(`${part.toUpperCase()}: ${state.facialDatabase[part].length}`);
            }
            
            // 檢查是否有任何五官載入成功
            const totalLoaded = state.facialDatabase.eyes.length + 
                              state.facialDatabase.ears.length + 
                              state.facialDatabase.nose.length + 
                              state.facialDatabase.mouth.length + 
                              state.facialDatabase.skin.length;
            
            if (totalLoaded > 0) {
                state.databaseReady = true;
                state.useExternalImages = true;
                addLog("EXTERNAL DB READY");
                addLog(`TOTAL: ${totalLoaded} images`);
                // 延遲生成碎片，確保 canvas 已正確初始化
                setTimeout(() => {
                    captureFacialFragments();
                }, 500);
            } else {
                addLog("NO EXTERNAL IMAGES");
                addLog("USING AUTO-BUILD");
                buildFacialDatabase();
            }
        }

        function init() {
            resize();
            captureCanvas.width = 640;
            captureCanvas.height = 480;
            setupEvents();
            requestAnimationFrame(loop);
            addLog("CORE LINK READY.");
        }

        function setupEvents() {
            document.getElementById('btnCam').onclick = () => {
                playSound('click');
                toggleCamera();
            };
            
            document.getElementById('btnRun').onclick = () => {
                playSound('click');
                toggleSystem();
            };
            
            setupKnob('knobDensity', (val) => {
                state.density = Math.floor(8 + val * 24); // 8-32 個碎片
                document.getElementById('valDensity').textContent = state.density;
                playSound('knob');
                // 立即重新生成碎片（如果資料庫已準備好）
                if (state.currentMode === 3 && state.databaseReady && state.isRunning) {
                    captureFacialFragments();
                }
            });
            
            setupKnob('knobDistort', (val) => {
                state.distortion = val;
                document.getElementById('valDistort').textContent = Math.floor(val*100) + '%';
                playSound('knob');
            });

            window.addEventListener('resize', resize);
        }

        function playSound(name) {
            if (sounds[name]) {
                sounds[name].currentTime = 0;
                sounds[name].play().catch(e => {});
            }
        }

        function setupKnob(id, callback) {
            let isDragging = false;
            let lastY = 0;
            let currentVal = (id === 'knobDensity') ? 0.5 : 0.7;
            const el = document.getElementById(id);
            
            el.onmousedown = (e) => { 
                isDragging = true; 
                lastY = e.clientY;
                el.classList.add('active');
            };
            
            window.onmousemove = (e) => {
                if (!isDragging) return;
                let delta = (lastY - e.clientY) * 0.005;
                currentVal = Math.min(1, Math.max(0, currentVal + delta));
                lastY = e.clientY;
                callback(currentVal);
            };
            
            window.onmouseup = () => { 
                isDragging = false;
                el.classList.remove('active');
            };
        }

        async function toggleCamera() {
            if (!state.cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
                    });
                    video.srcObject = stream;
                    state.cameraActive = true;
                    document.getElementById('indGreen').classList.add('active-green');
                    addLog("VIDEO LINK: ON");
                } catch (e) { addLog("ERR: NO CAMERA"); }
            } else {
                const stream = video.srcObject;
                if (stream) stream.getTracks().forEach(t => t.stop());
                video.srcObject = null;
                state.cameraActive = false;
                document.getElementById('indGreen').classList.remove('active-green');
                addLog("VIDEO LINK: OFF");
            }
        }

        function toggleSystem() {
            state.isRunning = !state.isRunning;
            document.getElementById('indRed').classList.toggle('active-red', state.isRunning);
            document.getElementById('disp-status').textContent = `SYS: ${state.isRunning ? 'OBSERVING' : 'STANDBY'}`;
            addLog(state.isRunning ? "INITIATING SCAN..." : "SCAN PAUSED.");
            
            if (state.isRunning && state.currentMode === 3 && state.cameraActive) {
                if (!state.databaseReady) {
                    // 先嘗試載入外部圖片，失敗則自動建立
                    loadExternalImages();
                } else {
                    captureFacialFragments();
                }
            }
        }

        function setMode(m) {
            state.currentMode = m;
            const names = ["", "1_MIRROR_STAGE", "2_DATA_DISCIPLINE", "3_HYPERREAL_SIM"];
            document.getElementById('disp-mode').textContent = `MODE: ${names[m]}`;
            
            document.querySelectorAll('.mode-target').forEach((el, i) => {
                el.classList.toggle('active', i === m - 1);
            });
            
            playSound('mode');
            addLog(`STAGE_${m} ACTIVATED.`);
            
            if (m === 3 && state.cameraActive && state.isRunning) {
                if (!state.databaseReady) {
                    // 先嘗試載入外部圖片，失敗則自動建立
                    loadExternalImages();
                } else {
                    captureFacialFragments();
                }
            }
        }

        // ==================== 臉部檢測 ====================
        function detectFaceCenter() {
            if (!video.readyState || video.readyState < 2) return;
            
            captureCtx.drawImage(video, 0, 0, captureCanvas.width, captureCanvas.height);
            const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
            const data = imageData.data;
            
            let maxBrightness = 0;
            let brightX = captureCanvas.width * 0.5;
            let brightY = captureCanvas.height * 0.45;
            
            const sampleSize = 20;
            for (let y = 100; y < captureCanvas.height - 100; y += sampleSize) {
                for (let x = 100; x < captureCanvas.width - 100; x += sampleSize) {
                    let brightness = 0, count = 0;
                    
                    for (let dy = 0; dy < sampleSize; dy++) {
                        for (let dx = 0; dx < sampleSize; dx++) {
                            const index = ((y + dy) * captureCanvas.width + (x + dx)) * 4;
                            brightness += (data[index] + data[index + 1] + data[index + 2]) / 3;
                            count++;
                        }
                    }
                    
                    brightness /= count;
                    if (brightness > maxBrightness) {
                        maxBrightness = brightness;
                        brightX = x + sampleSize / 2;
                        brightY = y + sampleSize / 2;
                    }
                }
            }
            
            state.faceCenter.x = brightX / captureCanvas.width;
            state.faceCenter.y = brightY / captureCanvas.height;
        }

        // ==================== 建立五官資料庫 ====================
        async function buildFacialDatabase() {
            if (!video.readyState || video.readyState < 2) return;
            
            addLog("BUILDING DATABASE...");
            
            state.facialDatabase = {
                eyes: [],
                ears: [],
                nose: [],
                mouth: [],
                skin: []
            };
            
            // 擷取20幀來建立資料庫
            for (let frame = 0; frame < 20; frame++) {
                await new Promise(resolve => setTimeout(resolve, 100)); // 等待100ms
                
                detectFaceCenter();
                
                captureCtx.save();
                captureCtx.scale(-1, 1);
                captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.restore();
                
                const faceCenterX = state.faceCenter.x * captureCanvas.width;
                const faceCenterY = state.faceCenter.y * captureCanvas.height;
                const faceWidth = state.faceSize.w * captureCanvas.width;
                const faceHeight = state.faceSize.h * captureCanvas.height;
                
                // 定義五官位置（相對於臉部中心）- 縮小範圍
                const positions = {
                    eyes: { x: 0, y: -0.15, w: 0.5, h: 0.2 },    // 雙眼區域（縮小）
                    ears: { x: 0, y: 0, w: 0.6, h: 0.4 },         // 耳朵區域（縮小）
                    nose: { x: 0, y: 0.1, w: 0.25, h: 0.3 },      // 鼻子（縮小）
                    mouth: { x: 0, y: 0.35, w: 0.4, h: 0.2 },    // 嘴巴（縮小）
                    skin: { x: 0, y: 0, w: 0.6, h: 0.6 }          // 皮膚（縮小）
                };
                
                // 擷取每個五官
                for (const [part, pos] of Object.entries(positions)) {
                    const partWidth = faceWidth * pos.w;
                    const partHeight = faceHeight * pos.h;
                    
                    const sourceX = Math.max(0, Math.min(
                        captureCanvas.width - partWidth,
                        faceCenterX + pos.x * faceWidth - partWidth / 2
                    ));
                    const sourceY = Math.max(0, Math.min(
                        captureCanvas.height - partHeight,
                        faceCenterY + pos.y * faceHeight - partHeight / 2
                    ));
                    
                    const partCanvas = document.createElement('canvas');
                    partCanvas.width = partWidth;
                    partCanvas.height = partHeight;
                    const partCtx = partCanvas.getContext('2d');
                    
                    partCtx.drawImage(
                        captureCanvas,
                        sourceX, sourceY, partWidth, partHeight,
                        0, 0, partWidth, partHeight
                    );
                    
                    state.facialDatabase[part].push(partCanvas);
                }
            }
            
            state.databaseReady = true;
            addLog(`DATABASE READY`);
            addLog(`EYES: ${state.facialDatabase.eyes.length}`);
            addLog(`NOSE: ${state.facialDatabase.nose.length}`);
            addLog(`MOUTH: ${state.facialDatabase.mouth.length}`);
            
            // 建立完成後，延遲生成碎片
            setTimeout(() => {
                captureFacialFragments();
            }, 500);
        }

        // ==================== 五官拼貼碎片生成 ====================
        // ==================== 五官拼貼碎片生成 ====================
        function captureFacialFragments() {
            if (!state.databaseReady) return;
            if (canvas.width === 0 || canvas.height === 0) {
                addLog("CANVAS NOT READY");
                return;
            }
            
            state.facialFragments = [];
            
            // 只選擇有內容的五官類型
            const availableParts = [];
            if (state.facialDatabase.eyes.length > 0) availableParts.push('eyes');
            if (state.facialDatabase.ears.length > 0) availableParts.push('ears');
            if (state.facialDatabase.nose.length > 0) availableParts.push('nose');
            if (state.facialDatabase.mouth.length > 0) availableParts.push('mouth');
            if (state.facialDatabase.skin.length > 0) availableParts.push('skin');
            
            if (availableParts.length === 0) {
                addLog("NO PARTS AVAILABLE");
                return;
            }
            
            // 為每個碎片隨機選擇五官
            for (let i = 0; i < state.density; i++) {
                // 隨機選擇五官類型（只從有內容的類型中選）
                const partType = availableParts[Math.floor(Math.random() * availableParts.length)];
                const partArray = state.facialDatabase[partType];
                
                // 隨機選擇該類型的一個五官
                const partCanvas = partArray[Math.floor(Math.random() * partArray.length)];
                
                // 隨機變形
                const transform = {
                    flipH: Math.random() > 0.7,
                    flipV: Math.random() > 0.85,
                    rotate: (Math.random() - 0.5) * 30,
                    scaleX: 0.7 + Math.random() * 0.6,
                    scaleY: 0.7 + Math.random() * 0.6
                };
                
                // **初始位置：圍繞在臉部中心周圍**
                const angle = Math.random() * Math.PI * 2;
                const radius = 80 + Math.random() * 100;  // 距離臉部中心 80-180px
                const startX = canvas.width/2 + Math.cos(angle) * radius;
                const startY = canvas.height/2 + Math.sin(angle) * radius;
                
                // **運動系統**
                state.facialFragments.push({
                    canvas: partCanvas,
                    width: partCanvas.width,
                    height: partCanvas.height,
                    partType,
                    transform,
                    // 位置與運動
                    x: startX,
                    y: startY,
                    vx: (Math.random() - 0.5) * 1,  // 減少初始速度
                    vy: (Math.random() - 0.5) * 1,
                    rotationSpeed: (Math.random() - 0.5) * 0.3,  // 減少旋轉速度
                    alpha: 0.8 + Math.random() * 0.2,
                    zIndex: Math.random()
                });
            }
            
            state.facialFragments.sort((a, b) => a.zIndex - b.zIndex);
            state.lastReshuffleTime = performance.now(); // 初始化時間戳
            addLog(`FRAGMENTS: ${state.facialFragments.length}`);
            addLog(`PARTS: ${availableParts.join(',')}`);
        }

        // ==================== 更新鏡子內容（保持運動） ====================
        function addLog(msg) {
            const el = document.getElementById('log-stream');
            const lines = el.innerHTML.split('<br>');
            el.innerHTML = msg + "<br>" + lines.slice(0, 2).join('<br>');
        }

        function resize() {
            const container = document.querySelector('.screen-container');
            if (container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }

        function loop(timestamp) {
            if (state.isRunning && state.cameraActive && video.readyState >= 2) {
                state.frameCount++;
                
                // 階段1和2：即時追蹤臉部
                if (state.currentMode === 1 || state.currentMode === 2) {
                    detectFaceCenter();
                }
                
                // 階段3：持續追蹤臉部
                if (state.currentMode === 3) {
                    detectFaceCenter();
                    
                    // 每10秒重新組合五官（使用資料庫）
                    if (timestamp - state.lastReshuffleTime > 10000 && state.databaseReady) {
                        captureFacialFragments();
                        state.lastReshuffleTime = timestamp;
                    }
                }
                
                render();
            }
            requestAnimationFrame(loop);
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function render() {
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            if (state.currentMode === 1) {
                // 階段1：掃描
                ctx.globalAlpha = 0.3;
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                state.scanProgress = (state.scanProgress + 2) % h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, state.scanProgress);
                ctx.lineTo(w, state.scanProgress);
                ctx.stroke();
                
                const gradient = ctx.createLinearGradient(0, state.scanProgress - 50, 0, state.scanProgress + 50);
                gradient.addColorStop(0, 'rgba(212, 165, 116, 0)');
                gradient.addColorStop(0.5, 'rgba(212, 165, 116, 0.2)');
                gradient.addColorStop(1, 'rgba(212, 165, 116, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, state.scanProgress - 50, w, 100);
                
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                const faceWidth = state.faceSize.w * w;
                const faceHeight = state.faceSize.h * h;
                
                ctx.strokeStyle = 'rgba(212, 165, 116, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.strokeRect(faceCenterX - faceWidth/2, faceCenterY - faceHeight/2, faceWidth, faceHeight);
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.arc(faceCenterX, faceCenterY, Math.min(faceWidth, faceHeight) * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                
            } else if (state.currentMode === 2) {
                // 階段2：色彩
                captureCtx.save();
                captureCtx.scale(-1, 1);
                captureCtx.drawImage(video, -captureCanvas.width, 0, captureCanvas.width, captureCanvas.height);
                captureCtx.restore();
                
                const imageData = captureCtx.getImageData(0, 0, captureCanvas.width, captureCanvas.height);
                const data = imageData.data;
                const time = performance.now() * 0.0012;
                const pixelSize = 15;
                const cols = Math.ceil(captureCanvas.width / pixelSize);
                const rows = Math.ceil(captureCanvas.height / pixelSize);
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let r = 0, g = 0, b = 0, count = 0;
                        
                        for (let py = 0; py < pixelSize; py++) {
                            for (let px = 0; px < pixelSize; px++) {
                                const sourceX = x * pixelSize + px;
                                const sourceY = y * pixelSize + py;
                                if (sourceX < captureCanvas.width && sourceY < captureCanvas.height) {
                                    const index = (sourceY * captureCanvas.width + sourceX) * 4;
                                    r += data[index]; 
                                    g += data[index + 1]; 
                                    b += data[index + 2];
                                    count++;
                                }
                            }
                        }
                        
                        if (count > 0) {
                            r = Math.floor(r / count); 
                            g = Math.floor(g / count); 
                            b = Math.floor(b / count);
                            
                            const hsl = rgbToHsl(r, g, b);
                            hsl.h = (hsl.h + time * 50 + x * 10 + y * 10) % 360;
                            hsl.s = Math.max(0, Math.min(100, hsl.s + Math.sin(time + x * 0.1) * 30));
                            hsl.l = Math.max(0, Math.min(100, hsl.l + Math.cos(time + y * 0.1) * 20));
                            
                            const drawX = (x * pixelSize) * (w / captureCanvas.width);
                            const drawY = (y * pixelSize) * (h / captureCanvas.height);
                            const drawSize = pixelSize * (w / captureCanvas.width);
                            
                            ctx.fillStyle = `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
                            ctx.fillRect(drawX, drawY, drawSize, drawSize);
                        }
                    }
                }
                
            } else if (state.currentMode === 3) {
                // 階段3：五官碎片自由遊走
                
                // 清晰背景人像（提高透明度）
                ctx.globalAlpha = 0.4;  // 從 0.08 提高到 0.4
                ctx.save();
                ctx.scale(-1, 1);
                ctx.drawImage(video, -w, 0, w, h);
                ctx.restore();
                ctx.globalAlpha = 1;
                
                // 如果沒有碎片，顯示訊息
                if (state.facialFragments.length === 0) {
                    ctx.fillStyle = 'rgba(212, 165, 116, 0.8)';
                    ctx.font = '14px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('WAITING FOR FRAGMENTS...', w/2, h/2);
                    ctx.fillText(`DB READY: ${state.databaseReady}`, w/2, h/2 + 20);
                    ctx.fillText(`CANVAS: ${canvas.width}x${canvas.height}`, w/2, h/2 + 40);
                    return;
                }
                
                // 即時臉部中心（用於推離力計算）
                const faceCenterX = state.faceCenter.x * w;
                const faceCenterY = state.faceCenter.y * h;
                
                // 更新並繪製所有碎片
                state.facialFragments.forEach(frag => {
                    // **運動更新：磁性吸引效果**
                    
                    const dx = faceCenterX - frag.x;
                    const dy = faceCenterY - frag.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 1. 磁性吸引力（會被臉部吸引，但保持一定距離）
                    const targetDistance = 100;  // 目標距離：100px（圍繞在臉部周圍）
                    
                    if (distance > targetDistance + 20) {
                        // 距離太遠 → 被吸引靠近
                        const attractionStrength = 0.05;  // 增強吸引力
                        const pull = (distance - targetDistance) / 200;
                        frag.vx += (dx / distance) * attractionStrength * pull;
                        frag.vy += (dy / distance) * attractionStrength * pull;
                    } else if (distance < targetDistance - 20) {
                        // 太靠近 → 輕微推開
                        const repulsionStrength = 0.02;
                        frag.vx -= (dx / distance) * repulsionStrength;
                        frag.vy -= (dy / distance) * repulsionStrength;
                    } else {
                        // 在理想範圍內 → 環繞運動
                        const orbitStrength = 0.01;
                        frag.vx += -dy / distance * orbitStrength;  // 切線方向
                        frag.vy += dx / distance * orbitStrength;
                    }
                    
                    // 2. 速度阻尼（讓運動更平滑）
                    frag.vx *= 0.95;
                    frag.vy *= 0.95;
                    
                    // 3. 隨機擾動（保持自由感）
                    frag.vx += (Math.random() - 0.5) * 0.1;
                    frag.vy += (Math.random() - 0.5) * 0.1;
                    
                    // 4. 限制速度
                    const maxSpeed = 2;
                    const speed = Math.sqrt(frag.vx * frag.vx + frag.vy * frag.vy);
                    if (speed > maxSpeed) {
                        frag.vx = (frag.vx / speed) * maxSpeed;
                        frag.vy = (frag.vy / speed) * maxSpeed;
                    }
                    
                    // 5. 更新位置
                    frag.x += frag.vx;
                    frag.y += frag.vy;
                    
                    // 6. 邊界處理：軟反彈
                    const margin = 30;
                    if (frag.x < margin) { frag.vx += 0.3; frag.x = margin; }
                    if (frag.x > w - margin) { frag.vx -= 0.3; frag.x = w - margin; }
                    if (frag.y < margin) { frag.vy += 0.3; frag.y = margin; }
                    if (frag.y > h - margin) { frag.vy -= 0.3; frag.y = h - margin; }
                    
                    // 7. 旋轉更新
                    frag.transform.rotate += frag.rotationSpeed;
                    
                    // **繪製碎片**
                    ctx.save();
                    
                    ctx.translate(frag.x, frag.y);
                    ctx.rotate(frag.transform.rotate * Math.PI / 180);
                    
                    let scaleX = frag.transform.scaleX;
                    let scaleY = frag.transform.scaleY;
                    if (frag.transform.flipH) scaleX *= -1;
                    if (frag.transform.flipV) scaleY *= -1;
                    ctx.scale(scaleX, scaleY);
                    
                    ctx.globalAlpha = frag.alpha;
                    
                    // 縮小碎片到二分之一
                    const displayWidth = frag.width * (w / captureCanvas.width) * 0.5;
                    const displayHeight = frag.height * (h / captureCanvas.height) * 0.5;
                    
                    // 繪製五官碎片
                    ctx.drawImage(frag.canvas, -displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    // 碎片邊框
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = 'rgba(212, 165, 116, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-displayWidth / 2, -displayHeight / 2, displayWidth, displayHeight);
                    
                    ctx.restore();
                });
            }
        }
        
        window.onload = init;
    </script>
</body>
</html>
