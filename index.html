<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªæˆ‘è§€æ¸¬å„€ | è¢«è§€çœ‹çš„è‡ªæˆ‘èˆ‡ä¸»é«”é‡æ§‹</title>
    <style>
        :root {
            --bg-dark: #020205;
            --panel-bg: rgba(10, 10, 20, 0.9);
            --accent-mirror: #00d4ff; 
            --accent-observation: #00ff88;
            --accent-simulacrum: #ff00ff;
            --text-main: #e0e0e0;
            --font-mono: 'Courier New', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', 'Microsoft JhengHei', sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 15px;
            padding: 15px;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        h1 { font-size: 1.1rem; letter-spacing: 2px; margin-bottom: 20px; text-transform: uppercase; border-bottom: 1px solid rgba(255, 255, 255, 0.2); padding-bottom: 10px; }
        h2 { font-size: 0.8rem; color: #888; margin: 15px 0 10px 0; text-transform: uppercase; }

        .stage-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid transparent;
            transition: all 0.5s;
        }
        .stage-1 .stage-control { border-color: var(--accent-mirror); box-shadow: 0 0 15px rgba(0, 212, 255, 0.2); }
        .stage-2 .stage-control { border-color: var(--accent-observation); box-shadow: 0 0 15px rgba(0, 255, 136, 0.2); }
        .stage-3 .stage-control { border-color: var(--accent-simulacrum); box-shadow: 0 0 15px rgba(255, 0, 255, 0.2); }

        .stage-label { font-size: 0.9rem; font-weight: bold; margin-bottom: 10px; display: block; text-align: center; }

        input[type="range"] {
            width: 100%; height: 4px; border-radius: 2px; appearance: none; background: #333; outline: none; margin: 10px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; cursor: pointer;
        }

        .eeg-group { margin-bottom: 12px; }
        .eeg-header { display: flex; justify-content: space-between; font-size: 0.75rem; color: #aaa; margin-bottom: 5px; }
        .eeg-val { color: #fff; font-weight: bold; }

        .canvas-container {
            position: relative;
            background: #000;
            overflow: hidden;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        canvas { width: 100%; height: 100%; object-fit: cover; }

        .overlay-ui {
            position: absolute; top: 20px; left: 20px; pointer-events: none;
            font-family: var(--font-mono); font-size: 0.8rem; z-index: 50;
        }
        .data-tag { background: rgba(0,0,0,0.8); padding: 4px 10px; border-radius: 4px; margin-bottom: 6px; border-left: 3px solid #fff; }

        .log-container {
            flex-grow: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            font-family: var(--font-mono);
            font-size: 0.7rem;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .log-entry { margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.02); }

        button {
            width: 100%; padding: 12px; margin-top: 10px;
            background: transparent; border: 1px solid #444; color: #fff;
            border-radius: 6px; cursor: pointer; transition: 0.3s;
            text-transform: uppercase; font-size: 0.75rem; letter-spacing: 1px;
        }
        button:hover { background: #fff; color: #000; }
        button.active { background: var(--accent-observation); border-color: #fff; color: #000; }
        button.camera-off { border-color: #ff4757; color: #ff4757; }

        .stage-1 .accent { color: var(--accent-mirror); }
        .stage-2 .accent { color: var(--accent-observation); }
        .stage-3 .accent { color: var(--accent-simulacrum); }

        #video { display: none; }
    </style>
</head>
<body class="stage-1">

    <video id="video" autoplay playsinline></video>

    <!-- å·¦å´é¢æ¿ -->
    <div class="panel">
        <h1>âš¡ ç³»çµ±è¨­ç½®</h1>
        
        <div class="stage-control">
            <span class="stage-label accent" id="stageName">éšæ®µ 1: å…·èº«é¡åƒ</span>
            <input type="range" id="stageSlider" min="1" max="3" step="1" value="1">
            <p style="font-size: 0.65rem; color: #666; text-align: center; line-height: 1.4;">
                èª¿æ•´éšæ®µä»¥è§€å¯Ÿä¸»é«”å¦‚ä½•åœ¨æ¼”ç®—æ³•ä¸­è¢«é€æ­¥é‡æ§‹ã€‚
            </p>
        </div>

        <h2>ç”Ÿç†è¨Šè™Ÿæ¨¡æ“¬ (EEG)</h2>
        <div id="eegSliders"></div>

        <h2>ç³»çµ±é‹ä½œ</h2>
        <button id="startBtn">â–¶ å•Ÿå‹•è§€æ¸¬å„€</button>
        <button id="cameraBtn" class="camera-off">ğŸ“· æ”å½±æ©Ÿï¼šé—œé–‰</button>
        <button id="resetBtn">âŸ³ é‡ç½®ä¸»é«”è³‡æ–™</button>
    </div>

    <!-- ä¸­å¤®ç•«å¸ƒ -->
    <div class="panel canvas-container" id="viewport">
        <div class="overlay-ui">
            <div class="data-tag accent" id="statusTag">STATUS: IDLE</div>
            <div class="data-tag" id="latencyTag">LATENCY: 0ms</div>
            <div class="data-tag" id="dbInfoTag">DATABASE: 0 FRAGMENTS</div>
            <div id="algorithmicTags"></div>
        </div>
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- å³å´é¢æ¿ -->
    <div class="panel">
        <h1>ğŸ“Š åˆ†ææ—¥èªŒ</h1>
        
        <div style="background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; font-family: monospace; font-size: 0.7rem; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between;"><span>å°é½Šåº¦:</span><span id="statAlignment">0%</span></div>
            <div style="display: flex; justify-content: space-between;"><span>ç†µå€¼:</span><span id="statEntropy">0.00</span></div>
            <div style="display: flex; justify-content: space-between;"><span>ä¸»é«”ä¸€è‡´æ€§:</span><span id="statSync">100%</span></div>
        </div>

        <div class="log-container" id="logBox"></div>

        <h2 style="margin-top: 20px;">å“²å­¸å¼•å°</h2>
        <p id="philosophyDesc" style="font-size: 0.75rem; color: #aaa; line-height: 1.6; font-style: italic;">
            å½±åƒä½œç‚ºä¸»é«”çš„å»¶ä¼¸ï¼Œåœ¨æ­¤éšæ®µï¼Œä½ èˆ‡å½±åƒä¿æŒè‘—ç¾è±¡å­¸å¼çš„çµ±ä¸€ã€‚
        </p>
    </div>

    <script>
        const config = {
            bands: [
                { id: 'delta', label: 'Delta', desc: 'æ·±å±¤æœ¬æˆ‘', val: 0.2 },
                { id: 'theta', label: 'Theta', desc: 'æ½›æ„è­˜æµ', val: 0.4 },
                { id: 'alpha', label: 'Alpha', desc: 'æ”¾é¬†æ„è­˜', val: 0.6 },
                { id: 'beta', label: 'Beta', desc: 'é‚è¼¯/ç„¦æ…®', val: 0.3 },
                { id: 'gamma', label: 'Gamma', desc: 'é«˜éšèªçŸ¥', val: 0.1 }
            ],
            stages: {
                1: { name: "éšæ®µ 1: å…·èº«é¡åƒ", desc: "ç¾è±¡å­¸è§€çœ‹ã€‚å½±åƒå³æ™‚åæ‡‰ï¼Œæ”å½±æ©Ÿæ•æ‰ä½ çš„è‚‰èº«ï¼Œé€éè…¦æ³¢èˆ‡ä½ ç”¢ç”Ÿå…·èº«é€£çµã€‚", color: "#00d4ff", delay: 100 },
                2: { name: "éšæ®µ 2: æ¼”ç®—æ³•éè§€æ¸¬", desc: "æ¬ŠåŠ›è¦è¨“ã€‚ç³»çµ±æ“·å–å½±åƒç‰‡æ®µé€²è¡Œæ•¸æ“šåŒ–åˆ†æï¼Œå‡ºç¾å»¶é²èˆ‡æƒææ ¼æŸµï¼Œä¸»é«”è¢«è½‰åŒ–ç‚ºè³‡æ–™é›†ã€‚", color: "#00ff88", delay: 2500 },
                3: { name: "éšæ®µ 3: æ“¬åƒé‡æ§‹", desc: "è¶…çœŸå¯¦é‡çµ„ã€‚çœŸå¯¦å½±åƒæ¶ˆé€ï¼Œç³»çµ±æ ¹æ“šä½ çš„æ•¸æ“šæ‹¼æ¹Šå‡ºç¢ç‰‡åŒ–çš„ä¸»é«”æ“¬åƒï¼Œå±•ç¾é«˜è®ŠåŒ–åº¦çš„äº”å®˜çµ„åˆã€‚", color: "#ff00ff", delay: 6000 }
            }
        };

        const state = {
            isRunning: false,
            cameraActive: false,
            currentStage: 1,
            eeg: {},
            buffer: [],
            frameCount: 0,
            video: document.getElementById('video'),
            facialDatabase: [] // å„²å­˜é ç”Ÿæˆçš„äº”å®˜ç‰‡æ®µ
        };

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const logBox = document.getElementById('logBox');

        function init() {
            initUI();
            generateFacialFragments();
            resize();
            window.addEventListener('resize', resize);
            addLog("è‡ªæˆ‘è§€æ¸¬ç³»çµ±å·²å°±ç·’ã€‚", "SYSTEM");
            requestAnimationFrame(loop);
        }

        function initUI() {
            const container = document.getElementById('eegSliders');
            config.bands.forEach(band => {
                state.eeg[band.id] = band.val;
                const div = document.createElement('div');
                div.className = 'eeg-group';
                div.innerHTML = `
                    <div class="eeg-header">
                        <span>${band.label}</span>
                        <span class="eeg-val" id="val-${band.id}">${Math.floor(band.val * 100)}%</span>
                    </div>
                    <input type="range" id="slider-${band.id}" min="0" max="100" value="${band.val * 100}">
                `;
                container.appendChild(div);
                document.getElementById(`slider-${band.id}`).oninput = (e) => {
                    state.eeg[band.id] = e.target.value / 100;
                    document.getElementById(`val-${band.id}`).textContent = e.target.value + '%';
                };
            });

            document.getElementById('stageSlider').oninput = (e) => setStage(parseInt(e.target.value));
            document.getElementById('startBtn').onclick = toggleSystem;
            document.getElementById('cameraBtn').onclick = toggleCamera;
            document.getElementById('resetBtn').onclick = resetSystem;
        }

        // ==================== äº”å®˜è³‡æ–™åº«ç”Ÿæˆ (v3 é‚è¼¯) ====================
        function generateFacialFragments() {
            state.facialDatabase = [];
            const types = ['eye', 'nose', 'mouth'];
            const eyeStyles = ['single', 'double', 'almond', 'round', 'hooded', 'downturned'];
            const noseStyles = ['high', 'flat', 'wide', 'narrow', 'aquiline'];
            const mouthStyles = ['smile', 'closed', 'thick', 'thin', 'pout', 'open'];

            for (let i = 0; i < 30; i++) {
                const fragCanvas = document.createElement('canvas');
                fragCanvas.width = 120;
                fragCanvas.height = 120;
                const fctx = fragCanvas.getContext('2d');
                
                // è†šè‰²èƒŒæ™¯
                const h = 20 + Math.random() * 20;
                const s = 30 + Math.random() * 40;
                const l = 50 + Math.random() * 30;
                fctx.fillStyle = `hsl(${h}, ${s}%, ${l}%)`;
                fctx.fillRect(0, 0, 120, 120);

                const type = types[i % 3];
                fctx.translate(60, 60);

                if (type === 'eye') {
                    drawEyeFragment(fctx, eyeStyles[Math.floor(Math.random()*eyeStyles.length)]);
                } else if (type === 'nose') {
                    drawNoseFragment(fctx, noseStyles[Math.floor(Math.random()*noseStyles.length)]);
                } else {
                    drawMouthFragment(fctx, mouthStyles[Math.floor(Math.random()*mouthStyles.length)]);
                }
                
                state.facialDatabase.push(fragCanvas);
            }
            document.getElementById('dbInfoTag').textContent = `DATABASE: ${state.facialDatabase.length} FRAGMENTS`;
            addLog("å®Œæˆ 30 çµ„é«˜è®ŠåŒ–åº¦äº”å®˜æ“¬åƒç”Ÿæˆã€‚", "DATABASE");
        }

        function drawEyeFragment(ctx, style) {
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 18, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.stroke();
            // ç³å­”
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc((Math.random()-0.5)*10, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // é«˜å…‰
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(-5, -5, 4, 0, Math.PI*2);
            ctx.fill();
        }

        function drawNoseFragment(ctx, style) {
            ctx.strokeStyle = "rgba(0,0,0,0.4)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.quadraticCurveTo(15, 0, 0, 30);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-10, 25, 5, 0, Math.PI*2);
            ctx.arc(10, 25, 5, 0, Math.PI*2);
            ctx.stroke();
        }

        function drawMouthFragment(ctx, style) {
            ctx.fillStyle = "rgba(180, 50, 50, 0.8)";
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 12, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath();
            ctx.moveTo(-40, 0);
            ctx.lineTo(40, 0);
            ctx.stroke();
        }

        // ==================== æ ¸å¿ƒå¾ªç’° ====================

        async function toggleCamera() {
            if (!state.cameraActive) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    state.video.srcObject = stream;
                    state.cameraActive = true;
                    document.getElementById('cameraBtn').textContent = "ğŸ“· æ”å½±æ©Ÿï¼šå•Ÿå‹•";
                    document.getElementById('cameraBtn').classList.remove('camera-off');
                    document.getElementById('cameraBtn').classList.add('active');
                    addLog("æ”å½±æ©Ÿå·²é€£é€šï¼Œè®€å–å…·èº«å½±åƒã€‚", "CAMERA");
                } catch (err) {
                    addLog("æ”å½±æ©Ÿå­˜å–å¤±æ•—ï¼Œè«‹ç¢ºèªæ¬Šé™ã€‚", "ERROR");
                }
            } else {
                const stream = state.video.srcObject;
                if (stream) stream.getTracks().forEach(track => track.stop());
                state.cameraActive = false;
                document.getElementById('cameraBtn').textContent = "ğŸ“· æ”å½±æ©Ÿï¼šé—œé–‰";
                document.getElementById('cameraBtn').classList.add('camera-off');
                document.getElementById('cameraBtn').classList.remove('active');
                addLog("æ”å½±æ©Ÿå·²æ–·é–‹ã€‚", "CAMERA");
            }
        }

        function setStage(s) {
            state.currentStage = s;
            document.body.className = `stage-${s}`;
            const data = config.stages[s];
            document.getElementById('stageName').textContent = data.name;
            document.getElementById('philosophyDesc').textContent = data.desc;
            document.getElementById('latencyTag').textContent = `LATENCY: ${data.delay}ms`;
            addLog(`ä¸»é«”é‡æ§‹ï¼šåˆ‡æ›è‡³ ${data.name}`, 'STAGE');
        }

        function toggleSystem() {
            state.isRunning = !state.isRunning;
            document.getElementById('startBtn').textContent = state.isRunning ? "â¸ åœæ­¢è§€æ¸¬" : "â–¶ å•Ÿå‹•è§€æ¸¬å„€";
            document.getElementById('statusTag').textContent = state.isRunning ? "STATUS: OBSERVING" : "STATUS: IDLE";
        }

        function resetSystem() {
            state.buffer = [];
            generateFacialFragments(); // é‡æ–°ç”Ÿæˆäº”å®˜åº«
            addLog("ç·©è¡å€èˆ‡äº”å®˜åº«å·²é‡æ–°æ¼”ç®—ã€‚", "RESET");
        }

        function addLog(msg, tag = 'SYS') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span style="color:#666">[${new Date().toLocaleTimeString().split(' ')[0]}]</span> <span class="accent">[${tag}]</span> ${msg}`;
            logBox.prepend(entry);
            if(logBox.children.length > 25) logBox.lastChild.remove();
        }

        function loop() {
            if (state.isRunning) {
                state.frameCount++;
                const delayFrames = Math.floor(config.stages[state.currentStage].delay / 16);
                
                state.buffer.push({ eeg: {...state.eeg} });
                if (state.buffer.length > delayFrames + 1) state.buffer.shift();
                
                const activeEEG = state.buffer[0].eeg;
                render(activeEEG);
                updateStats();
            }
            requestAnimationFrame(loop);
        }

        function render(eeg) {
            const w = canvas.width;
            const h = canvas.height;
            const t = performance.now() * 0.001;

            ctx.fillStyle = `rgba(0,0,0,${state.currentStage === 1 ? 0.3 : 0.1})`;
            ctx.fillRect(0, 0, w, h);

            // è™•ç†æ”å½±æ©ŸèƒŒæ™¯ (éšæ®µ 1 & 2)
            if (state.cameraActive && state.currentStage < 3) {
                ctx.save();
                if (state.currentStage === 1) {
                    ctx.translate(w, 0); ctx.scale(-1, 1); // é¡åƒ
                    ctx.globalAlpha = 0.6 + Math.sin(t) * 0.1;
                } else {
                    ctx.globalAlpha = 0.25;
                    ctx.filter = 'grayscale(100%) contrast(150%)';
                }
                ctx.drawImage(state.video, 0, 0, w, h);
                ctx.restore();
            }

            ctx.save();
            ctx.translate(w/2, h/2);

            if (state.currentStage === 1) {
                drawMirrorWave(eeg, t);
            } else if (state.currentStage === 2) {
                drawObservationGrid(w, h, eeg, t);
            } else {
                drawSimulacrumCollage(w, h, eeg, t);
            }
            ctx.restore();
        }

        function drawMirrorWave(eeg, t) {
            ctx.strokeStyle = config.stages[1].color;
            ctx.lineWidth = 2.5;
            ctx.shadowBlur = 15;
            ctx.shadowColor = config.stages[1].color;
            ctx.beginPath();
            const pts = 90;
            for(let i=0; i<=pts; i++){
                const ang = (i/pts) * Math.PI * 2;
                const r = 180 + Math.sin(ang * (6 + eeg.gamma*10) + t*2.5) * (40 + eeg.beta*100);
                const x = Math.cos(ang) * r;
                const y = Math.sin(ang) * r;
                i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        function drawObservationGrid(w, h, eeg, t) {
            const color = config.stages[2].color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5;
            const step = 45;
            // æ ¼æŸµ
            for(let x=-w/2; x<w/2; x+=step) {
                ctx.beginPath(); ctx.moveTo(x, -h/2); ctx.lineTo(x, h/2); ctx.stroke();
            }
            for(let y=-h/2; y<h/2; y+=step) {
                ctx.beginPath(); ctx.moveTo(-w/2, y); ctx.lineTo(w/2, y); ctx.stroke();
            }
            // ç‰¹å¾µé»
            ctx.fillStyle = color;
            for(let i=0; i<8; i++) {
                const ox = Math.sin(t*0.7 + i) * 220;
                const oy = Math.cos(t*0.4 + i) * 220;
                ctx.strokeRect(ox-20, oy-20, 40, 40);
                ctx.font = "10px monospace";
                ctx.fillText(`FEAT_SCAN_${i}: ${(eeg.alpha*100).toFixed(1)}%`, ox+25, oy);
            }
            // æ©«å‘æƒæç·š
            const scanY = (Math.sin(t*2) * 0.5 + 0.5) * h - h/2;
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(-w/2, scanY); ctx.lineTo(w/2, scanY); ctx.stroke();
        }

        function drawSimulacrumCollage(w, h, eeg, t) {
            const cols = 5, rows = 4;
            const cellW = w / cols, cellH = h / rows;
            const color = config.stages[3].color;

            for(let i=0; i<cols; i++) {
                for(let j=0; j<rows; j++) {
                    const x = (i - cols/2 + 0.5) * cellW;
                    const y = (j - rows/2 + 0.5) * cellH;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    
                    // éš¨æ©Ÿé¸æ“‡é ç”Ÿæˆçš„äº”å®˜ç‰‡æ®µ
                    const seed = Math.floor(Math.abs(Math.sin(i*j + Math.floor(t*0.5)) * state.facialDatabase.length));
                    const fragment = state.facialDatabase[seed % state.facialDatabase.length];
                    
                    ctx.rotate(Math.sin(t + i*j) * 0.3 * eeg.gamma);
                    ctx.scale(0.8 + eeg.alpha*0.4, 0.8 + eeg.alpha*0.4);
                    
                    // ç¹ªè£½ç¢ç‰‡
                    ctx.drawImage(fragment, -60, -60, 110, 110);
                    
                    // æ•¸ä½é‚Šç•Œç·š
                    ctx.strokeStyle = `rgba(255, 0, 255, ${0.1 + Math.random()*0.3})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-cellW/2 + 5, -cellH/2 + 5, cellW-10, cellH-10);
                    
                    ctx.restore();
                }
            }
        }

        function updateStats() {
            const s = state.currentStage;
            document.getElementById('statAlignment').textContent = `${Math.floor(100 - s * 28)}%`;
            document.getElementById('statEntropy').textContent = (s * 0.35 + Math.random()*0.05).toFixed(2);
            document.getElementById('statSync').textContent = `${Math.floor(100/s)}%`;
        }

        function resize() {
            const vp = document.getElementById('viewport');
            canvas.width = vp.clientWidth;
            canvas.height = vp.clientHeight;
        }

        window.onload = init;
    </script>
</body>
</html>
